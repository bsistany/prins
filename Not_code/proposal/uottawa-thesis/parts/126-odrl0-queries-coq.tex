%======================================================================
\chapter{Queries}\label{chap:queries}
%======================================================================

% ---------------------------------------------------------

\section{Introduction}


We first mentioned queries in chapter~\ref{chap:semantics} on page~\pageref{chap:semantics}. Ultimately policy statements describing an agreement will be used to enforce those agreements. To enforce policy agreements, access queries are asked from the policy engine and access is granted or denied based on the answer.

By defining formal semantics for \ac{odrl} the authors of ~\cite{pucella2006} were able to prove that answering a query on whether access should be granted or not, is decidable and NP-hard for the full \ac{odrl}. 

In this chapter we will review our encoding of queries in Coq and Coq representations of other definitions used in ~\cite{pucella2006} which we will use to prove decidability results of our own. 


\section{Queries}

Queries are tuples of the form $(A, s, action, a, e)$ in ~\cite{pucella2006}. The tuple corresponds to the question of determining whether a set $A$ of agreements imply that a subject $s$ may perform action $action$ on an asset $a$ given the environment $e$. The Coq representation is listed in listing~\ref{lst:querycoq}. We distinguish single agreement queries from multiple agreement queries by defining two separate types: $single\_query$ and $general\_query$.

\lstset{language=Coq, frame=single, caption={Queries},label={lst:querycoq}}
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}

Inductive single_query : Set := 
   | SingletonQuery : agreement -> subject -> act -> asset -> environment -> single_query.
   

Inductive general_query : Set := 
   | GeneralQuery : nonemptylist agreement -> subject -> act -> asset -> environment -> general_query.
\end{lstlisting}
\end{minipage}

\section{Answering Queries}

Answering a query as defined earlier can lead to one of four outcomes: error(listing~\ref{lst:errordecision}), permitted(listing~\ref{lst:permitdecision}), denied(listing~\ref{lst:denydecision}) and ``not applicable'' (listing~\ref{lst:notapplicabledecision}) defined in ~\cite{Tschantz}.

\lstset{mathescape, language=AST} 
\begin{lstlisting}[frame=single, caption={Answerable Queries: Error},label={lst:errordecision}]

$(\bigwedge [\![ agreement]\!]) \land E \implies Permitted(s, act, a)$ and $(\bigwedge [\![ agreement]\!]) \land E \implies \lnot Permitted(s, act, a)$

\end{lstlisting}

\lstset{mathescape, language=AST} 
\begin{lstlisting}[frame=single, caption={Answerable Queries: Permit},label={lst:permitdecision}]

$(\bigwedge [\![ agreement]\!]) \land E \implies Permitted(s, act, a)$ and $(\bigwedge [\![ agreement]\!]) \land E \notimplies \lnot Permitted(s, act, a)$

\end{lstlisting}

\lstset{mathescape, language=AST} 
\begin{lstlisting}[frame=single, caption={Answerable Queries: Deny},label={lst:denydecision}]

$(\bigwedge [\![ agreement]\!]) \land E \notimplies Permitted(s, act, a)$ and $(\bigwedge [\![ agreement]\!]) \land E \implies \lnot Permitted(s, act, a)$

\end{lstlisting}

\lstset{mathescape, language=AST} 
\begin{lstlisting}[frame=single, caption={Answerable Queries: Not Applicable},label={lst:notapplicabledecision}]

$(\bigwedge [\![ agreement]\!]) \land E \notimplies Permitted(s, act, a)$ and $(\bigwedge [\![ agreement]\!]) \land E \notimplies \lnot Permitted(s, act, a)$

\end{lstlisting}


In~\cite{pucella2006} a slightly different formulation is used to denote the same four decision types. ``Query Inconsistent'',``Permission Granted'', ``Permission Denied'' and ``Permission Unregulated''. They define the formulas $f^{+}_q$ and $f^{-}_q$ as below (see listings~\ref{lst:fplusformula} and~\ref{lst:fminusformula}).

\lstset{mathescape, language=AST} 
\begin{lstlisting}[frame=single, caption={$f^{+}_q$},label={lst:fplusformula}]

$f^{+}_q \triangleq (\bigwedge [\![ agreement]\!]) \implies Permitted(s, act, a)$ 

\end{lstlisting}

\lstset{mathescape, language=AST} 
\begin{lstlisting}[frame=single, caption={$f^{-}_q$},label={lst:fminusformula}]

$f^{-}_q \triangleq (\bigwedge [\![ agreement]\!]) \implies \lnot Permitted(s, act, a)$ 

\end{lstlisting}

Now answering the queries will depend on the \emph{E-validity} of $f^{+}_q$ and $f^{-}_q$. E-validity or the consistency of the environment is not captured explicitly in~\cite{pucella2006} (see listings~\ref{lst:queryinconsistentdecision}, ~\ref{lst:permissiongranteddecision}, ~\ref{lst:permissiondenieddecision} and~\ref{lst:permissionunregulateddecision}) however the decision of which answer a query results in takes the consistency of the environment into account. In this thesis we will encode and use the decision algorithms in~\cite{pucella2006}.


\lstset{mathescape, language=AST} 
\begin{lstlisting}[frame=single, caption={Answerable Queries: Query Inconsistent},label={lst:queryinconsistentdecision}]

$f^{+}_q$ and $f^{-}_q$ both hold

\end{lstlisting}

\lstset{mathescape, language=AST} 
\begin{lstlisting}[frame=single, caption={Answerable Queries: Permission Granted},label={lst:permissiongranteddecision}]

$f^{+}_q$ holds and $f^{-}_q$ does not hold

\end{lstlisting}

\lstset{mathescape, language=AST} 
\begin{lstlisting}[frame=single, caption={Answerable Queries: Permission Denied},label={lst:permissiondenieddecision}]

$f^{+}_q$ does not hold and $f^{-}_q$ holds

\end{lstlisting}

\lstset{mathescape, language=AST} 
\begin{lstlisting}[frame=single, caption={Answerable Queries: Permission Unregulated},label={lst:permissionunregulateddecision}]

$f^{+}_q$ does not hold and $f^{-}_q$ does not hold

\end{lstlisting}


























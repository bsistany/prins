%======================================================================
\chapter{ODRL0 Syntax}
\label{chap:odrl0syntax}
%======================================================================

\section{Introduction}

Authors of \cite{pucella2006} use abstract syntax instead of XML (ODRL 2.0 can also be encoded in \emph{JSON} and \emph{RDF/OWL Ontology}) to express statements in the \ac{odrl} language. Abstract syntax is a more compact representation than XML in which ODRL policies may be written in and furthermore abstract syntax simplifies specifying the semantics as we shall see later. As an example the agreement ``If Mary Smith pays five dollars, then she is allowed to print the eBook 'Treasure Island' twice and she is allowed to display it on her computer as many times as she likes'' written in ODRL's XML encoding and the equivalent one expressed in the abstract syntax \cite{pucella2006}.

\lstset{language=XML}
\begin{lstlisting}[caption={agreement for Mary Smith in XML},label={lst:agreementxml}]
<agreement>
 <asset> <context> <uid> Treasure Island </uid> </context> </asset>
 <permission>
   <display>
    <constraint>
     <cpu> <context> <uid> Mary's computer </uid> </context> </cpu>
    </constraint>
   </display>
   <print>
    <constraint> <count> 2 </count> </constraint>
   </print>
  <requirement>
   <prepay>
    <payment> <amount currency="AUD"> 5.00</amount> </payment>
   </prepay>
  </requirement>
 </permission>
 <party> <context> <name> Mary Smith </name> </context> </party>
</agreement>
\end{lstlisting}

The agreement in listing~\ref{lst:agreementxml} is shown below using the syntax from \cite{pucella2006}.

\lstset{language=Pucella2006}
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}[frame=single, caption={agreement for Mary Smith as BNF (as used in ~\cite{pucella2006})},label={lst:agreementpucella2006}]
agreement
 for Mary Smith 
 about Treasure Island 
 with prePay[5.00] -> and[cpu[Mary's Computer] => display,
                                      count[2] => print].
\end{lstlisting}
\end{minipage} 

% \emph{prin\textsubscript{u}}
In the following we will cover the \emph{abstract syntax} of a subset of ODRL that we later express using Coq's constructs such as \emph{Inductive Types} and Definitions. We will call this subset \emph{ODRL0} both because it is a variation of Pucella's ODRL language and also because it is missing some constructs from Pucella's ODRL (and hence from ODRL proper). 

\section{ODRL0}\label{sec:odrl0}
In ODRL0, agreements and facts (i.e. environments) will only contain the number of times each policy has been used to justify an action. In ODRL0 agreements and facts will not contain: \begin{enumerate}
  \item Which payments have been made
  \item Which acknowledgments have been made
\end{enumerate} 

This means \emph{Paid} and \emph{Attributed} predicates are not used in ODRL0. Also removed are related constructs \emph{prepay} and \emph{attribution}. We also had to remove two other constructs based on $prepay$ and $attribution$ out of ODRL0 in \emph{inSeq} and \emph{anySeq}. $prepay$, $attribution$, $inSeq$ and $anySeq$ make up what is called \emph{requirements} in ODRL.

In ODRL a \emph{prerequisite} is either $true$, a $constraint$, a $requirement$ or a $condition$. $true$ is the prerequisite that always holds. Constraints are facts that are outside of control of users. For example, there is nothing $Alice$ can do to satisfy the constraint ``user must be Bob''. Requirements are facts that are in users' control. For example, $Alice$ may satisfy the requirement ``The user must pay 5 dollars''. Finally conditions are constraints that must not hold.

In ODRL0, a prerequisite is either $true$, a $constraint$, or the negation of a $constraint$. So we have removed requirements from the picture and don't have explicit conditions. Conditions are replaced by a category called $NotCons$ directly in the production for prerequisites (see listing~\ref{lst:preRequisiteast}). Note that we have also removed the condition $not[policySet]$ from ODRL since the authors in \cite{pucella2006} have shown the semantics of this component are not well-defined and including it leads to intractability results.

We will add the missing pieces as described above (except for $not[policySet]$) making up what we will call \emph{ODRL1} and perhaps \emph{ODRL2} (the latter only if needed). We will also describe ODRL0 in a \emph{BNF} grammar that looks more like Pucella's ODRL grammar. BNF style grammars are less formal as they give some suggestions about the surface syntax of expressions [Pierce1] without getting into lexical analysis and parsing related aspects such as precedence order of operators. The Coq version in contrast is more formal and could be directly used for building compilers and interpreters. We will present both the BNF version and the Coq version for each construct of ODRL0 [Pierce1]. To get started let's see what the listing~\ref{lst:agreementpucella2006} would look like in ODRL0's Coq version.

\lstset{language=Coq}
\begin{lstlisting}[frame=single, caption={Coq version of agreement for Mary Smith},label={lst:marysmithagreementcoq}]

Agreement (Single MarySmith) Treasure Island 
 (PrimitivePolicySet (Constraint (PrePay 5.00))
  (AndPolicy 
   (NewList (PrimitivePolicy (Constraint 
                              (Principal 
                               (Single MarysComputer))) id1 Display)
   (Single (PrimitivePolicy (Constraint (Count 2)) id2 Print))))).
\end{lstlisting}


%\coqdoceol
%\coqdocvar{Agreement} (\coqdocvar{Single} \coqdocvar{Mary Smith}) \coqdocvar{Treasure Island} (\coqdocvar{PrimitivePolicySet} (\coqdocvar{Constraint} (\coqdocvar{PrePay} 5.00))\coqdoceol
%\coqdocindent{0.50em}
%(\coqdocvar{AndPolicy} (\coqdocvar{NewList} (\coqdocvar{PrimitivePolicy} (\coqdocvar{Constraint} (\coqdocvar{Principal} (\coqdocvar{Single} \coqdocvar{Mary's Computer}))) \coqdocvar{id1} \coqdocvar{Display})\coqdoceol
%\coqdocindent{6.00em}
%(\coqdocvar{Single} (\coqdocvar{PrimitivePolicy} (\coqdocvar{Constraint} (\coqdocvar{Count} 2)) \coqdocvar{id2} \coqdocvar{Print}))))).\coqdoceol
%\coqdocemptyline
%\coqdocemptyline

\section{Productions} \label{sec:productionast}

The top level ODRL0 production is the \emph{agreement}. An agreement expresses what actions a set of subjects may perform on an object and under what conditions. Syntactically an agreement is composed of a set of subjects/users called a \emph{principal} or \emph{prin}, an \emph{asset} and a \emph{policySet}.

% agreement
\lstset{language=AST}
\begin{lstlisting}[frame=single, caption={agreement},label={lst:agreementast}]
<agreement> ::= 'agreement' 'for' <prin> 'about' <asset> 'with' <policySet> 
\end{lstlisting}

Principals or prins are composed of \emph{subjects} which are specified based on the application e.g. Alice, Bob, etc for the %\ac{drm} 
application we will be using throughout.

% prin
\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={prin},label={lst:prinast}]
<prin> ::=  { <subject$_{1}$>, ..., <subject$_{m}$> }
\end{lstlisting}

% subject
\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={subject},label={lst:subjectast}]
<subject> ::= N
\end{lstlisting}

Assets are also application specific but similar to subjects we will use specific ones for the DRM application (taken from \cite{pucella2006}). \emph{ebook}, \emph{The Report} and \emph{latestJingle} are examples of specific subjects we will be using throughout. Syntactically an asset is represented as a natural number (\emph{N}). Similarly for subjects.

% asset
\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={asset},label={lst:assetast}]
<asset> ::= N
\end{lstlisting}

Agreements include policy sets. Each policy set specifies a \emph{prerequisite} and a \emph{policy}. In general if the prerequisite holds the policy is taken into consideration. Otherwise the policy will not be looked at. Some policy sets are specified as \emph{exclusive}. The \emph{Primitive Exclusive Policy Sets} are exclusive to agreement's users in that only those users may perform the actions specified in the policy set. The implication is that all other users who are not specified in the agreement's principal (prin) are forbidden from performing the specified actions. Finally policy sets could be grouped together in a \emph{conjunction} allowing a single agreement to be associated with many policy sets. 


% policySet
\newcommand*{\Comment}[1]{\hfill\makebox[7.0cm][l]{#1}}%
\lstset{mathescape, language=AST, escapechar=\&}  
\begin{lstlisting}[frame=single, caption={policySet},label={lst:policySetast}]
<policySet> ::=  
	<preRequisite> $\rightarrow$ <policy>	&\Comment{; primitive policy set }&
	<preRequisite> $\mapsto$ <policy>		&\Comment{; primitive exclusive policy set }&
	'and'[ <policySet$_{1}$>, ..., <policySet$_{m}$> ]	&\Comment{; conjunction }&
\end{lstlisting}

A policy specifies an action to be performed on an asset, depending of whether the policy's prerequisite holds or not. If the prerequisite holds the agreement's user is permitted to perform the action on the agreement's asset; otherwise permission is denied. Similar to policy sets, policies could also be grouped together in a conjunction. The policy also includes a unique identifier. The policy identifier is added to help the translation (from agreements to formulas) but is optional in ODRL proper.

% policy

\lstset{mathescape, language=AST, escapechar=\&}  
\begin{lstlisting}[frame=single, caption={policy},label={lst:policyast}]
<policy> ::=  
	<preRequisite> $\Rightarrow_{<policyId>}$ <act> &\Comment{; primitive policy}&
	'and'[ <policy$_{1}$>, ..., <policy$_{m}$> ] &\Comment{; conjunction }&
\end{lstlisting}

An \emph{Action} (\emph{act}) is represented as a natural number. Similar to assets and subjects, actions are application specific. Some example actions taken from \cite{pucella2006} are \emph{Display} and \emph{Print}.

% act
\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={act},label={lst:actast}]
<act> ::= N
\end{lstlisting}

A \emph{Policy Id} (\emph{policyId}) is a unique identifier specified as (increasing) positive integers. 

% id
\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={policyId},label={lst:policyIdast}]
<policyId> ::= N
\end{lstlisting}

In ODRL0 a \emph{prerequisite} is either true or it is a \emph{constraint}. The \emph{true} prerequisite always holds. A constraint is an intrinsic part of a policy and cannot be influenced by agreement's user. Minimum height requirements for popular attractions and rides are examples of we would consider a constraint. The constraint \emph{ForEachMember} is interesting in its expressive power but has complicated semantics as we shall see in the ~\ref{sec:Semantics} section. Roughly speaking, ForEachMember takes a prin (a list of subjects) and a list L of constraints. The ForEachConstraint holds if each subject in prin satisfies each constraint in L.\emph{NotCons} is a negation of a constraint. The set of prerequisites are closed under conjunction (\emph{AndPrqs}), disjunction (\emph{OrPrqs}) and exclusive disjunction (\emph{XorPrqs}).

% prq

\lstset{mathescape, language=AST, escapechar=\&}  
\begin{lstlisting}[frame=single, caption={preRequisite},label={lst:preRequisiteast}]
<preRequisite> ::=  
	'True' &\Comment{; always true}&
	<constraint>	 &\Comment{; constraint}&
	'ForEachMember' [<prin> ; <constraint$_{1}$>, ..., <constraint$_{m}$> ]	&\Comment{; constraint distribution}&
	'not' [ <constraint> ] &\Comment{; suspending constraint}&
	'and'[ <preRequisite$_{1}$>, ..., <preRequisite$_{m}$> ] &\Comment{; conjunction }&
	'or'[ <preRequisite$_{1}$>, ..., <preRequisite$_{m}$> ] &\Comment{; disjunction}&
	'xor'[ <preRequisite$_{1}$>, ..., <preRequisite$_{m}$> ] &\Comment{; exclusive disjunction}&
\end{lstlisting}

Constraints are either \emph{Principal}, \emph{Count} or \emph{CountByPrin}. Principal constraints basically require matching to specified prins. For example, the user being Alice is a Principal constraint. A count constraint refers to a set of policies \emph{P} and specifies the number of times the user of an agreement has invoked the policies in P to justify her actions. If the count constraint is part of a policy then the set P is composed of the single policy. In the case that the count constraint is part of a policy set, the set P is the set of policies specified in the policy set.

% constraint
\lstset{mathescape, language=AST, escapechar=\&}  
\begin{lstlisting}[frame=single, caption={constraint},label={lst:constraintast}]
<constraint> ::=  
	<prin> &\Comment{; principal}&
	'Count' [N] &\Comment{; number of executions}&
	<prin> ('Count' [N]) &\Comment{; number of executions by prin}&
\end{lstlisting}

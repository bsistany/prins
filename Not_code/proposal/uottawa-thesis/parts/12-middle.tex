%======================================================================
\chapter{Middle}
%======================================================================

%----------------------------------------------------------------------
\section{Logic Based Semantics for ODRL}
%----------------------------------------------------------------------

%See equation \ref{eqn_pi} on page \pageref{eqn_pi}.\footnote{A famous %equation.}

Formal logic can represent the statements and facts we express in a natural language like English. Propositional logic is expressive enough to express simple facts as propositions and uses connectives to allow for the negation, conjunction and disjunction of the facts. However propositional logic is not expressive enough to express policies of the kind used in languages like ODRL and XrML. For example, a simple policy expressed in English like ``All who pay 5 dollars can watch the movie Toy Story'' cannot be expressed in propositional logic because the concept of  variables doesn't exist in propositional logic. 

A richer logic called ``Predicate Logic'' or ``First Order Logic'' (\emph{FOL}) is more suitable and has the expressive power to represent policies written in English. Moreover, FOL can be used to capture the meaning of policies in an unambiguous way.

Halpern and Weissman [Using First Order Logic to Reason about Policies] propose a fragment of FOL to represent and reason about policies. The fragment of FOL they arrive at is called \emph{Lithium} which is decidable and allows for efficiently answering interesting queries. Lithium restricts policies to be written based on the concept of ``bipolarity'' which disallows by construction policies that both permit and deny an action on an object.

\section{Pucella 2006}
Pucella and Weissman \cite{pucella2006} specify a predicate logic based based language that represents a subset of ODRL.

\section{what will I do?}


\subsection{Coq}


	• Program correctness
	• Formal verification of software
	• Certified programs
	• Proof assistant
	• Interactive and mechanized theorem proving
	• Examples of machine assisted proofs: CompCert, four-color theorem proof
	• Coq is based on a higher-order functional programming language
	• Dependent Types
		○ Subset types
		○ Easier than writing explicit proofs
	• Write formal specification and proofs that programs comply to their specification (a-short-intro-to-coq)
	• Automatically extract code from specifications as Ocaml or Haskell (a-short-intro)
	• Properties, programs and proofs are all formalized in the same language called CIC (Calculus of inductive Constructions). (a-short-intro)
	• Coq uses a sort called Prop for propositions
	• Coq art:
	• Well-formed propositions are assertions  one can express about values such as mathematical objects or even programs e.g. 3 < 8
		○ Note that assertions may be true, false or simply conjectures
		○ An assertion is only true in general if a proof is provided
		○ However hand written proofs are difficult to verify
		○ Coq provides an environment for developing proofs including a formal language to express proofs in, the language itself being built using proof theory making it possible to step by step verification of the proofs
		○ Mechanized proof verification requires a "proof" that the verification algorithm is correct itself in applying all the formal rules correctly







\section{Abstract Syntax}

Authors of \cite{pucella2006} use abstract syntax instead of XML to express statements in the ODRL language. The abstract syntax used is a more compact representation than XML based language ODRL policies are written in and furthermore it simplifies specifying the semantics as we shall see. As an example here is an agreement written in ODRL and the comparable agreement expressed in the abstract syntax \cite{pucella2006}.

\lstset{language=XML}
\begin{lstlisting}[caption={agreement for Mary Smith in XML},label={lst:agreementxml}]
<agreement>
 <asset> <context> <uid> Treasure Island </uid> </context> </asset>
 <permission>
   <display>
    <constraint>
     <cpu> <context> <uid> Mary's computer </uid> </context> </cpu>
    </constraint>
   </display>
   <print>
    <constraint> <count> 2 </count> </constraint>
   </print>
  <requirement>
   <prepay>
    <payment> <amount currency="AUD"> 5.00</amount> </payment>
   </prepay>
  </requirement>
 </permission>
 <party> <context> <name> Mary Smith </name> </context> </party>
</agreement>
\end{lstlisting}

The agreement ~\ref{lst:agreementxml} is shown below using the syntax from \cite{pucella2006}.

\lstset{language=Pucella2006}
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}[frame=single, caption={agreement for Mary Smith as BNF (as used in ~\cite{pucella2006})},label={lst:agreementpucella2006}]
agreement
 for Mary Smith 
 about Treasure Island 
 with prePay[5.00] -> and[cpu[Mary's Computer] => display,
                                      count[2] => print].
\end{lstlisting}
\end{minipage} 

% \emph{prin\textsubscript{u}}
In the following we will cover the \emph{abstract syntax} of a subset of ODRL expressed as Coq's constructs such as \emph{Inductive Types} and Definitions. We will call this subset \emph{ODRL0} both because it is a variation of Pucella's ODRL language and also because it is missing some constructs from Pucella's ODRL. 

\subsection{Odrl0}\label{subsec:odrl0}
In ODRL0, agreements and facts (i.e. environments) will only contain the number of times each policy has been used to justify an action. In ODRL0 agreements and facts will not contain: \begin{enumerate}
  \item Which payments have been made
  \item Which acknowledgments have been made
\end{enumerate} 

This means \emph{Paid} and \emph{Attributed} predicates are not used in ODRL0. Also removed are related constructs \emph{prepay} and \emph{attribution}. We also had to remove two other constructs based on $prepay$ and $attribution$ out of ODRL0 in \emph{inSeq} and \emph{anySeq}. $prepay$, $attribution$, $inSeq$ and $anySeq$ make up what is called \emph{requirements} in ODRL.

In ODRL a \emph{prerequisite} is either $true$, a $constraint$, a $requirement$ or a $condition$. $true$ is the prerequisite that always holds. Constraints are facts that are outside of control of users. For example, there is nothing $Alice$ can do to satisfy the constraint ``user must be Bob''. Requirements are facts that are in users' control. For example, $Alice$ may satisfy the requirement ``The user must pay 5 dollars''. Finally conditions are constraints that must not hold.

In ODRL0, a prerequisite is either $true$, a $constraint$, or not a $constraint$. So we have removed requirements from the picture and don't have explicit conditions. Conditions are replaced by a category called $NotCons$ directly in the production for prerequisites (see \ref{lst:preRequisiteast}). Note that we have also removed the condition $not[policySet]$ from ODRL since the authors in \cite{pucella2006} have shown the semantics of this component are not well-defined and including it leads to intractability results.

We will add the missing pieces as described above (except for $not[policySet]$) making up what we will call \emph{ODRL1} and perhaps \emph{ODRL2} (the latter only if needed). We will also describe ODRL0 in a \emph{BNF} grammar that looks more like Pucella's ODRL grammar. BNF style grammars are less formal as they give some suggestions about the surface syntax of expressions [Pierce1] without getting into lexical analysis and parsing related aspects such as precedence order of operators. The Coq version in contrast is more formal and could be directly used for building compilers and interpreters. We will present both the BNF version and the Coq version for each construct of ODRL0 [Pierce1]. To get started let's see what the listing ~\ref{lst:agreementpucella2006} would look like in ODRL0's Coq version.

\lstset{language=Coq}
\begin{lstlisting}[frame=single, caption={Coq version of agreement for Mary Smith},label={lst:marysmithagreementcoq}]

Agreement (Single MarySmith) Treasure Island 
 (PrimitivePolicySet (Constraint (PrePay 5.00))
  (AndPolicy 
   (NewList (PrimitivePolicy (Constraint 
                              (Principal 
                               (Single MarysComputer))) id1 Display)
   (Single (PrimitivePolicy (Constraint (Count 2)) id2 Print))))).
\end{lstlisting}


%\coqdoceol
%\coqdocvar{Agreement} (\coqdocvar{Single} \coqdocvar{Mary Smith}) \coqdocvar{Treasure Island} (\coqdocvar{PrimitivePolicySet} (\coqdocvar{Constraint} (\coqdocvar{PrePay} 5.00))\coqdoceol
%\coqdocindent{0.50em}
%(\coqdocvar{AndPolicy} (\coqdocvar{NewList} (\coqdocvar{PrimitivePolicy} (\coqdocvar{Constraint} (\coqdocvar{Principal} (\coqdocvar{Single} \coqdocvar{Mary's Computer}))) \coqdocvar{id1} \coqdocvar{Display})\coqdoceol
%\coqdocindent{6.00em}
%(\coqdocvar{Single} (\coqdocvar{PrimitivePolicy} (\coqdocvar{Constraint} (\coqdocvar{Count} 2)) \coqdocvar{id2} \coqdocvar{Print}))))).\coqdoceol
%\coqdocemptyline
%\coqdocemptyline

The top level ODRL0 production is the \emph{agreement}. An agreement expresses what actions a set of subjects may perform on an object and under what conditions. Syntactically an agreement is composed of a set of subjects/users called a \emph{principal} or \emph{prin}, an \emph{asset} and a \emph{policySet}.

% agreement
\lstset{language=AST}
\begin{lstlisting}[frame=single, caption={agreement},label={lst:agreementast}]
<agreement> ::= 'agreement' 'for' <prin> 'about' <asset> 'with' <policySet> 
\end{lstlisting}

Principals or prins are composed of \emph{subjects} which are specified based on the application e.g. Alice, Bob, etc for the DRM application we will be using throughout.

% prin
\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={prin},label={lst:prinast}]
<prin> ::=  { <subject$_{1}$>, ..., <subject$_{m}$> }
\end{lstlisting}

% subject
\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={subject},label={lst:subjectast}]
<subject> ::= N
\end{lstlisting}

Assets are also application specific but similar to subjects we will use specific ones for the DRM application (taken from \cite{pucella2006}). \emph{ebook}, \emph{The Report} and \emph{latestJingle} are examples of specific subjects we will be using throughout. Syntactically an asset is represented as a natural number (\emph{N}). Similarly for subjects.

% asset
\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={asset},label={lst:assetast}]
<asset> ::= N
\end{lstlisting}

Agreements include policy sets. Each policy set specifies a \emph{prerequisite} and a \emph{policy}. In general if the prerequisite holds the policy is taken into consideration. Otherwise the policy will not be looked at. Some policy sets are specified as \emph{exclusive}. The \emph{Primitive Exclusive Policy Sets} are exclusive to agreement's users in that only those users may perform the actions specified in the policy set. The implication is that all other users who are not specified in the agreement's principal (prin) are forbidden from performing the specified actions. Finally policy sets could be grouped together in a \emph{conjunction} allowing a single agreement to be associated with many policy sets. 


% policySet
\newcommand*{\Comment}[1]{\hfill\makebox[7.0cm][l]{#1}}%
\lstset{mathescape, language=AST, escapechar=\&}  
\begin{lstlisting}[frame=single, caption={policySet},label={lst:policySetast}]
<policySet> ::=  
	<preRequisite> $\rightarrow$ <policy>	&\Comment{; primitive policy set }&
	<preRequisite> $\mapsto$ <policy>		&\Comment{; primitive exclusive policy set }&
	'and'[ <policySet$_{1}$>, ..., <policySet$_{m}$> ]	&\Comment{; conjunction }&
\end{lstlisting}

A policy specifies an action to be performed on an asset, depending of whether the policy's prerequisite holds or not. If the prerequisite holds the agreement's user is permitted to perform the action on the agreement's asset; otherwise permission is denied. Similar to policy sets, policies could also be grouped together in a conjunction. The policy also includes a unique identifier. The policy identifier is added to help the translation (from agreements to formulas) but is optional in ODRL proper.

% policy

\lstset{mathescape, language=AST, escapechar=\&}  
\begin{lstlisting}[frame=single, caption={policy},label={lst:policyast}]
<policy> ::=  
	<preRequisite> $\Rightarrow_{<policyId>}$ <act> &\Comment{; primitive policy}&
	'and'[ <policy$_{1}$>, ..., <policy$_{m}$> ] &\Comment{; conjunction }&
\end{lstlisting}

An \emph{Action} (\emph{act}) is represented as a natural number. Similar to assets and subjects, actions are application specific. Some example actions taken from \cite{pucella2006} are \emph{Display} and \emph{Print}.

% act
\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={act},label={lst:actast}]
<act> ::= N
\end{lstlisting}

A \emph{Policy Id} (\emph{policyId}) is a unique identifier specified as (increasing) positive integers. 

% id
\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={policyId},label={lst:policyIdast}]
<policyId> ::= N
\end{lstlisting}

In ODRL0 a \emph{prerequisite} is either true or it is a \emph{constraint}. The \emph{true} prerequisite always holds. A constraint is an intrinsic part of a policy and cannot be influenced by agreement's user. Minimum height requirements for popular attractions and rides are examples of we would consider a constraint. The constraint \emph{ForEachMember} is interesting in its expressive power but has complicated semantics as we shall see in the ~\ref{sec:Semantics} section. Roughly speaking, ForEachMember takes a prin (a list of subjects) and a list L of constraints. The ForEachConstraint holds if each subject in prin satisfies each constraint in L.\emph{NotCons} is a negation of a constraint. The set of prerequisites are closed under conjunction (\emph{AndPrqs}), disjunction (\emph{OrPrqs}) and exclusive disjunction (\emph{XorPrqs}).

% prq

\lstset{mathescape, language=AST, escapechar=\&}  
\begin{lstlisting}[frame=single, caption={preRequisite},label={lst:preRequisiteast}]
<preRequisite> ::=  
	'True' &\Comment{; always true}&
	<constraint>	 &\Comment{; constraint}&
	'ForEachMember' [<prin> ; <constraint$_{1}$>, ..., <constraint$_{m}$> ]	&\Comment{; constraint distribution}&
	'not' [ <constraint> ] &\Comment{; suspending constraint}&
	'and'[ <preRequisite$_{1}$>, ..., <preRequisite$_{m}$> ] &\Comment{; conjunction }&
	'or'[ <preRequisite$_{1}$>, ..., <preRequisite$_{m}$> ] &\Comment{; disjunction}&
	'xor'[ <preRequisite$_{1}$>, ..., <preRequisite$_{m}$> ] &\Comment{; exclusive disjunction}&
\end{lstlisting}

Constraints are either \emph{Principal}, \emph{Count} or \emph{CountByPrin}. Principal constraints basically require matching to specified prins. For example, the user being Alice is a Principal constraint. A count constraint refers to a set of policies \emph{P} and specifies the number of times the user of an agreement has invoked the policies in P to justify her actions. If the count constraint is part of a policy then the set P is composed of the single policy. In the case that the count constraint is part of a policy set, the set P is the set of policies specified in the policy set.

% constraint
\lstset{mathescape, language=AST, escapechar=\&}  
\begin{lstlisting}[frame=single, caption={constraint},label={lst:constraintast}]
<constraint> ::=  
	<prin> &\Comment{; principal}&
	'Count' [N] &\Comment{; number of executions}&
	<prin> ('Count' [N]) &\Comment{; number of executions by prin}&
\end{lstlisting}

% ---------------------------------- COQ -----------------------
\section{Coq Version}

\lstset{language=Coq}
\begin{lstlisting}[frame=single, caption={Coq version of agreement},label={lst:agreementcoq}]
Inductive agreement : Set :=
  | Agreement : prin -> asset -> policySet -> agreement.
\end{lstlisting}

% prin 
\lstset{language=Coq}
\begin{lstlisting}[frame=single, caption={prin},label={lst:princoq}]
Definition prin := nonemptylist subject.
\end{lstlisting}

% asset
\lstset{language=Coq}
\begin{lstlisting}[frame=single, caption={asset},label={lst:assetcoq}]
Definition asset := nat.
\end{lstlisting}



% subject
\lstset{language=Coq}
\begin{lstlisting}[frame=single, caption={subject},label={lst:subjectcoq}]
Definition subject := nat.
\end{lstlisting}


% policySet
\lstset{language=Coq}
\begin{lstlisting}[frame=single, caption={policySet},label={lst:policySetcoq}]
Inductive policySet : Set :=
  | PrimitivePolicySet : preRequisite -> policy -> policySet 
  | PrimitiveExclusivePolicySet : preRequisite -> policy  -> policySet 
  | AndPolicySet : nonemptylist policySet -> policySet.
\end{lstlisting}

% policy
\lstset{language=Coq}
\begin{lstlisting}[frame=single, caption={policy},label={lst:policycoq}]
Inductive policy : Set :=
  | PrimitivePolicy : preRequisite -> policyId -> act -> policy 
  | AndPolicy : nonemptylist policy -> policy.
\end{lstlisting}

% act
\lstset{language=Coq}
\begin{lstlisting}[frame=single, caption={act},label={lst:actcoq}]
Definition act := nat.
\end{lstlisting}

% id
\lstset{language=Coq}
\begin{lstlisting}[frame=single, caption={policyId},label={lst:policyIdcoq}]
Definition policyId := nat.
\end{lstlisting}

% prq
\lstset{language=Coq}
\begin{lstlisting}[frame=single, caption={preRequisite},label={lst:preRequisitecoq}]
Inductive preRequisite : Set :=
  | TruePrq : preRequisite
  | Constraint : constraint -> preRequisite 
  | ForEachMember : prin  -> nonemptylist constraint -> preRequisite
  | NotCons : constraint -> preRequisite 
  | AndPrqs : nonemptylist preRequisite -> preRequisite
  | OrPrqs : nonemptylist preRequisite -> preRequisite
  | XorPrqs : nonemptylist preRequisite -> preRequisite.
\end{lstlisting}

% constraint
\lstset{language=Coq}
\begin{lstlisting}[frame=single, caption={constraint},label={lst:constraintcoq}]
Inductive constraint : Set :=
  | Principal : prin  -> constraint 
  | Count : nat -> constraint 
  | CountByPrin : prin -> nat -> constraint.
\end{lstlisting}


%----------------------------------------------------------------------
\section{Semantics}
\label{sec:Semantics}

In this section, we describe the semantics of ODRL0 language by a translation from agreements to a subset of many-sorted first-order logic formulas with equality. The semantics will help answer queries of the form ``may subject \emph{s} perform action \emph{act} to asset \emph{a}?''. If the answer is yes, we say permission is granted. Otherwise permission is denied. 


At a high-level, an agreement is translated into a conjunction of formulas of the form $\forall x ( prerequisites(x) \rightarrow P(x))$ where $P(x)$ itself is a conjunction of formulas of the form $ prerequisites(x) \rightarrow (\lnot) Permitted (x, act, a)$, where ``Permitted (x, act, a)'' means the subject $x$ is permitted to perform action $act$ on asset $a$.

\subsection{Agreement Translation}
The translation of an $agreement$ returns the translation for a $policySet$ per $prin_{u}$, the agreement's user and $a$, the asset.


\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Agreement Translation},label={lst:transAgreementast}]
$[\![ agreement$ $for$ $prin_{u}$ $about$ $a$ $with$ $ps]\!]$ $\triangleq$ $[\![policySet]\!]^{prin_{u}, a}$
\end{lstlisting}

\subsection{Policy Set Translation}
The translation for a $policySet$ ($[\![policySet]\!]^{prin_{u}, a}$) is described by translation formulas for each type of $policySet$. A $policySet$ is either a $PrimitivePolicySet$, a $\linebreak PrimitiveExclusivePolicySet$ or a $AndPolicySet$.

\subsubsection{PrimitivePolicySet Translation}
Translation of a $PrimitivePolicySet$ ($preRequisite \rightarrow policy$) yields a formula that includes a test on whether the subject is in the set of agreements' users, the translation of the policy and the translation of the $prerequisite$. Basically if the subject in question is a user of the agreement and the policySet prerequisites hold, then the policy holds. Translation of the policy for a $PrimitivePolicySet$ is called a \emph{positive translation}. A positive translation is one where the actions described by the policies are permitted.   

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Policy Set Translation {$\colon$} PrimitivePolicySet},label={lst:transpolicyformulaPrimitivePolicySet}]
$[\![ preRequisite \rightarrow policy]\!]^{e, prin_{u}, a}$ $\triangleq$ $\forall x$ $(\!( [\![prin_{u}]\!]_{x}$ $\land$ $[\![preRequisite]\!]^{e, getId (p), prin_{u}, a}_{x}) \rightarrow [\![policy]\!]^{positive, e, prin_{u}, a}_{x}\!)$
\end{lstlisting}



\lstset{mathescape, language=AST} 
\begin{lstlisting}[frame=single, caption={Positive Policy Translation {$\colon$} Single policy},label={lst:transpolicypositiveSingle}]

$[\![ preRequisite \Rightarrow_{policyId} act ]\!]^{positive, e, prin_{u}, a}_{x}$ $\triangleq$ $([\![ preRequisite ]\!]^{e, policyId, prin_{u}}_{x}) \Rightarrow Permitted(x, [\![act]\!], a)$

\end{lstlisting}


If the policy is a $AndPolicy$, the translation yields a conjunction of positive translations of each policy in turn.

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Positive Policy Translation {$\colon$} List of policies},label={lst:transpolicypositiveListOfPolicies}]

$[\![ and [policy_{1}, ..., policy_{m}]]\!]^{positive, e, prin_{u}, a}$ $\triangleq$ $[\![policy_{1}]\!]^{positive, e, prin_{u}, a}$ $\land$ $...$ $\land$ $[\![policy_{m}]\!]^{positive, e, prin_{u}, a}$

\end{lstlisting}


\subsubsection{PrimitiveExclusivePolicySet Translation}
$PrimitiveExclusivePolicySet$ ($preRequisite \mapsto policy$) yields the conjunction of two implications. The first implication, is the same as one found in the translation of $PrimitivePolicySet$. The second implication however restricts access (to make the policy set exclusive) to only those subjects that are in the agreement's user. Translation of the policy in the second implication is called a \emph{negative translation}. A negative translation is one where the actions described by the policies are not permitted. 


\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Policy Set Translation {$\colon$} PrimitiveExclusivePolicySet},label={lst:transpolicyformulaPrimitiveExclusivePolicySet}]
$[\![ preRequisite \mapsto policy]\!]^{e, prin_{u}, a}$ $\triangleq$ $\forall x$ $(\!( [\![prin_{u}]\!]_{x}$ $\land$ $[\![preRequisite]\!]^{e, getId (p), prin_{u}, a}_{x}) \rightarrow [\![policy]\!]^{positive, e, prin_{u}, a}_{x}\!)$ $\land$ $\forall x$ $(\neg[\![prin_{u}]\!]_{x} \rightarrow [\![policy]\!]^{negative, e, a}_{x})$
\end{lstlisting}


\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Negative Policy Translation {$\colon$} Single policy},label={lst:transpolicynegativeSingle}]

$[\![ preRequisite \Rightarrow_{policyId} act ]\!]^{negative, e, prin_{u}, a}_{x}$ $\triangleq$ $([\![ preRequisite ]\!]^{e, policyId, prin_{u}}_{x}) \Rightarrow \lnot (Permitted(x, [\![act]\!], a))$
\end{lstlisting}

If the policy is a $AndPolicy$, the translation yields a conjunction of negative translations of each policy in turn.

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Negative Policy Translation {$\colon$} List of policies},label={lst:transpolicynegativeListOfPolicies}]

$[\![ and [policy_{1}, ..., policy_{m}]]\!]^{negative, e, a}$ $\triangleq$ $[\![policy_{1}]\!]^{negative, e, a}$ $\land$ $...$ $\land$ $[\![policy_{m}]\!]^{negative, e, a}$

\end{lstlisting}

\subsubsection{AndPolicySet Translation}
$AndPolicySet$ translates to conjunctions of the corresponding policy set translations. 

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Policy Set Translation {$\colon$} AndPolicySet},label={lst:transpolicyformulaAndPolicySet}]
$[\![ and [policySet_{1}, ..., policySet_{m}]]\!]^{e, prin_{u}, a}$ $\triangleq$ $[\![policySet_{1}]\!]^{e, prin_{u}, a}$ $\land$ $...$ $\land$ $[\![policySet_{m}]\!]^{e, prin_{u}, a}$

\end{lstlisting}

\subsection{Principal Translation}
Translation for a \emph{prin} ($[\![ prin ]\!]_{x}$) is a formula that is true if and only if the subject $x$ is in the prin set. A $prin$ is either a single subject or a list of subjects ($\{ subject_{1}, ..., subject_{m} \}$ so the translation covers both cases. 


If the $prin$ is a single subject, the translation is a formula that is true if and only if the subject $x$ is the same as the single subject $subject$.

\subsubsection{Single Subject Translation}
\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Prin Translation {$\colon$} Single subject},label={lst:transprinSingle}]
$[\![ subject ]\!]_{x}$ $\triangleq$ $x=subject$
\end{lstlisting}

\subsubsection{List of Subjects Translation}
Translation of a list of subjects is the disjunction of the translations for each subject.

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Prin Translation {$\colon$} List of subjects},label={lst:transprinListOfSubjects}]

$[\![ \{ subject_{1}, ..., subject_{m} \} ]\!]_{x}$ $\triangleq$ $[\![subject_{1}]\!]_{x}$ $\lor$ $...$ $\lor$ $[\![subject_{m}]\!]_{x}$

\end{lstlisting}




\subsection{Prerequisite Translation}

Translation for a prerequisite is a formula $[\![prerequisite]\!]^{[id_{1}, ..., id_{m}], prin, a}_{x}$, where the set of $id$s refer to identifiers for policies that are implied by the prerequisites, $prin$ is the agreement's user(s) (and to which the prerequisites apply), $a$ is the asset and $x$ is a variable of type $subject$. The translation for a $prerequisite$ is described by translation formulas for each type of $prerequisite$. A $prerequisite$ is either always $true$, a $Constraint$, a $ForEachMember$, a $NotCons$, a $AndPrqs$, a $OrPrqs$ or a $XorPrqs$.

\subsubsection{True Prerequisite Translation}
The translation for a $TruePrq$ yields a formula that is always \emph{true}.

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Prerequisite Translation {$\colon$} Always True Prerequisite},label={lst:transpreRequisiteTruePrq}]
	$[\![ prerequisite::true ]\!]$ $\triangleq$ True
\end{lstlisting}

\subsubsection{Constraint Prerequisite Translation}
The translation for a $Constraint$ is handled by a specialized constraint translation function (coverage of which starts at ~\ref{lst:transconstraintPrin}.

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Prerequisite Translation {$\colon$} Constraint},label={lst:transpreRequisiteConstraint}]

$[\![ prerequisite::constraint ]\!]^{[id_{1}, ..., id_{m}], prin_{u}}_{x}$ $\triangleq$ $[\![ constraint ]\!]^{[id_{1}, ..., id_{m}], prin_{u}}_{x}$ 
\end{lstlisting}

\subsubsection{ForEachMember Prerequisite Translation}
The translation for a $ForEachMember$ is also is handled by a specialized translation function (covered at ~\ref{lst:transforEachMember}.

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Prerequisite Translation {$\colon$} ForEachMember},label={lst:transpreRequisiteForEachMember}]

$[\![ prerequisite::forEachMember ]\!]^{[subject_{1}, ..., subject_{k}], [constraint_{1}, ..., constraint_{m}], [id_{1}, ..., id_{n}]}_{x}$ $\triangleq$ $[\![ forEachMember ]\!]^{[subject_{1}, ..., subject_{k}], [constraint_{1}, ..., constraint_{m}], [id_{1}, ..., id_{n}]}_{x}$ 	
\end{lstlisting}

\subsubsection{NotCons Prerequisite Translation}
The translation for a $NotCons$ yields a formula that is simply the negation of the translation for a constraint.

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Prerequisite Translation {$\colon$} Not Constraint},label={lst:transpreRequisiteNotConstraint}]

$[\![ not$ $prerequisite::constraint ]\!]^{[id_{1}, ..., id_{m}], prin_{u}}_{x}$ $\triangleq$ $\lnot[\![ constraint ]\!]^{[id_{1}, ..., id_{m}], prin_{u}}_{x}$ 
\end{lstlisting}

\subsubsection{AndPrqs Prerequisite Translation}
The translation for a $AndPrqs$ yields a formula that is the conjunction of the translation for each $preRequisite$.

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Prerequisite Translation {$\colon$} Conjunction },label={lst:transpreRequisiteAndPrqs}]

$[\![and$ $[preRequisite_{1}, ..., preRequisite_{k}]]\!]^{[id_{1}, ..., id_{m}], prin_{u}}$ $\triangleq$ $[\![preRequisite_{1}]\!]^{[id_{1}, ..., id_{m}], prin_{u}}$ $\land$ $...$ $\land$ $[\![preRequisite_{k}]\!]^{[id_{1}, ..., id_{m}], prin_{u}}$

\end{lstlisting}

\subsubsection{OrPrqs Prerequisite Translation}
The translation for a $OrPrqs$ yields a formula that is the inclusive disjunction of the translation for each $preRequisite$.

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Prerequisite Translation {$\colon$} Inclusive Disjunction},label={lst:transpreRequisiteOrPrqs}]

$[\![or$ $[preRequisite_{1}, ..., preRequisite_{k}]]\!]^{[id_{1}, ..., id_{m}], prin_{u}}$ $\triangleq$ $[\![preRequisite_{1}]\!]^{[id_{1}, ..., id_{m}], prin_{u}}$ $\lor$ $...$ $\lor$ $[\![preRequisite_{k}]\!]^{[id_{1}, ..., id_{m}], prin_{u}}$

\end{lstlisting}

\subsubsection{XorPrqs Prerequisite Translation}
The translation for a $XorPrqs$ yields a formula that is the exclusive disjunction of the translation for each $preRequisite$.


\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Prerequisite Translation {$\colon$} Exclusive Disjunction},label={lst:transpreRequisiteXorPrqs}]

$[\![Xor$ $[preRequisite_{1}, ..., preRequisite_{k}]]\!]^{[id_{1}, ..., id_{m}], prin_{u}}$ $\triangleq$ $[\![preRequisite_{1}]\!]^{[id_{1}, ..., id_{m}], prin_{u}}$ $\oplus $ $...$ $\oplus$ $[\![preRequisite_{k}]\!]^{[id_{1}, ..., id_{m}], prin_{u}}$

\end{lstlisting}


\subsection{Constraint Translation}

Translation for a constraint is a formula $[\![constraint]\!]^{[id_{1}, ..., id_{m}], prin_{u}, a}_{x}$, where the set of $id$s refer to identifiers for policies that are implied by the constraint, $prin_{u}$ is the agreement's user(s) (and to which the constraint applies), $a$ is the asset and $x$ is a variable of type $subject$. The translation for a $constraint$ is described by translation formulas for each type of $constraint$. A $constraint$ is either a $Principal$, a $Count$, or a $CountByPrin$.

\subsubsection{Principal Constraint Translation}
The translation for a $Principal$ is handled by a specialized translation function (covered at ~\ref{lst:transprin}.   

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Constraint Translation {$\colon$} Principal},label={lst:transconstraintPrin}]

$[\![ constraint::prin ]\!]^{[subject_{1}, ..., subject_{m}]}_{x}$ $\triangleq$ $[\![ prin ]\!]^{[subject_{1}, ..., subject_{m}]}_{x}$ 
\end{lstlisting}

\subsubsection{Count Constraint Translation}
The translation for a $Count$ is handled by a specialized translation function (covered at ~\ref{lst:transcount}.

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Constraint Translation {$\colon$} Count},label={lst:transconstraintCount}]

$[\![ constraint::count [N] ]\!]^{[id_{1}, ..., id_{m}], prin_{u}}_{x}$ $\triangleq$ $[\![ count [N] ]\!]^{[id_{1}, ..., id_{m}], prin_{u}}_{x}$ 
\end{lstlisting}

\subsubsection{CountByPrin Constraint Translation}
The translation for a $CountByPrin$ is handled by the same specialized translation function as that for $Count$. The difference is that $CountByPrin$ overrides the subjects in $prin_{u}$ by a different set of subjects (covered at ~\ref{lst:transcount}.

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Constraint Translation {$\colon$} Count by Principal},label={lst:transconstraintCountbyPrin}]

$[\![ constraint::prin(count [N]) ]\!]^{[subject_{1}, ..., subject_{m}], [id_{1}, ..., id_{n}]}_{x}$ $\triangleq$ $[\![ prin(count [N]) ]\!]^{[subject_{1}, ..., subject_{m}], [id_{1}, ..., id_{n}]}_{x}$ 
\end{lstlisting}


\subsection{forEachMember Translation}

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={ForEachMember Translation {$\colon$} Count by Principal},label={lst:transforEachMember}]

$[\![ forEachMember ]\!]^{[subject_{1}, ..., subject_{k}], [constraint_{1}, ..., constraint_{m}], [id_{1}, ..., id_{n}]}_{x}$ $\triangleq$ $[\![constraint]\!]^{(subject_{1}, constraint_{1}), [id_{1}, ..., id_{n}]}_{x}$ $\land$ $...$ $\land$ $[\![constraint]\!]^{(subject_{1}, constraint_{m}), [id_{1}, ..., id_{n}]}_{x}$ $\land$ $...$ $\land$ $[\![constraint]\!]^{(subject_{2}, constraint_{1}), [id_{1}, ..., id_{n}]}_{x}$ $\land$ $...$ $\land$ $[\![constraint]\!]^{(subject_{2}, constraint_{m}), [id_{1}, ..., id_{n}]}_{x}$ $\land$ $...$ $\land$ $[\![constraint]\!]^{(subject_{k}, constraint_{1}), [id_{1}, ..., id_{n}]}_{x}$ $\land$ $...$ $\land$ $[\![constraint]\!]^{(subject_{k}, constraint_{m}), [id_{1}, ..., id_{n}]}_{x}$ 

\end{lstlisting}

\subsection{''Not Constraint" Translation}

The translation for ``Not Constraint'' was listed in listing ~\ref{lst:transpreRequisiteNotConstraint} earlier but we repeat it here to go along the Coq version. 

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Not Constraint Translation},label={lst:transnotCons}]

$[\![ not$ $constraint ]\!]^{[id_{1}, ..., id_{m}], prin_{u}}_{x}$ $\triangleq$ $\lnot[\![ constraint ]\!]^{[id_{1}, ..., id_{m}], prin_{u}}_{x}$ 

\end{lstlisting}

\subsection{Count Translation}
\subsubsection{Count Translation For Subject/ID Pair}
The translation for $Count$ or $CountByPrin$ for a pair of subject and policy identifier is a formula that is true if the number of times the $subject_{1}$ has invoked a policy with policy identifier $id_{1}$ is smaller than $N$.

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Count Translation {$\colon$} subject and policyId pair},label={lst:transcountSinglePair}]

$[\![ count [N] ]\!]^{subject_{1}, id_{1}}_{x}$ $\triangleq$ $getCount(subject_{1}, id_{1}) < N$
\end{lstlisting}

\subsubsection{Count Translation For Subject/ID Pairs}
The translation for $Count$ or $CountByPrin$ for subject and policy identifier pairs is a formula that is true if the total number of times that a subject has invoked a policy with policy identifier $id_{i}$ is smaller than $N$.

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Count Translation {$\colon$} subject and policyId pairs},label={lst:transcountPairs}]

$[\![ count [N] ]\!]^{[id_{1}, ..., id_{m}], prn}_{x}$ $\triangleq$ 

$(getCount(getSubject(prn)_{1}, id_{1})$ $+ ... +$ $getCount(getSubject(prn)_{1}, id_{m})$ $+ ... +$ $getCount(getSubject(prn)_{k}, id_{1})$ $+ ... +$ $getCount(getSubject(prn)_{k}, id_{m}))$ < $N$


\end{lstlisting}






\section{Semantics in Coq}
\label{sec:Semanticsincoq}

% COQ
The translation functions plus the auxiliary types and infrastructure, implementing the semantics have been encoded in Coq. Translation functions all return the \emph{sort} $Prop$. 

Talk about Props here...


Whether a permission is granted or denied depends on the agreements in question but also on the facts recorded in the environment. For ODRL0 those facts revolve around the number of times a policy has been used to justify an action (see \ref{subsec:odrl0} for more details on odrl0). We encode this information in an \emph{environment} which is a conjunction of equalities of the form \emph{count(s, policyId) = n}. 

% COQ
The Coq version of the count equality is a new inductive type called \emph{count_equality}. An environment is defined to be a non-empty list of count_equality objects.

\lstset{language=Coq, frame=single, caption={Environments and Counts},label={lst:environmentcoq}}
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
Inductive count_equality : Set := 
   | CountEquality : subject -> policyId -> nat -> count_equality.

Inductive environment : Set := 
  | SingleEnv : count_equality -> environment
  | ConsEnv :  count_equality ->  environment -> environment.

\end{lstlisting}
\end{minipage}

The non-empty list data structure is defined as a new \emph{polymorphic} inductive type in its own section. The non-empty list definition is listed at listing ~\ref{lst:nonemptylistcoq}.

\lstset{language=Coq, frame=single, caption={nonemptylist type},label={lst:nonemptylistcoq}}
\begin{lstlisting}

Section nonemptylist.

Variable X : Set.

Inductive nonemptylist : Set :=
  | Single : X -> nonemptylist 
  | NewList : X -> nonemptylist -> nonemptylist.

End nonemptylist.
\end{lstlisting}

Translation of the top level $agreement$ element proceeds by case analysis on the structure of the agreement. However an agreement can only be built one way; by calling the constructor $Agreement$. The translation proceeds by calling the translation function for the corresponding $policySet$ namely the parameter to $Agreement$ called $ps$.


\lstset{language=Coq, frame=single, caption={Translation of agreement},label={lst:transagreement}}
\begin{lstlisting}

Definition trans_agreement (e:environment)(ag:agreement) : Prop :=
  match ag with 
    | Agreement prin_u a ps => trans_ps e ps prin_u a
  end.

\end{lstlisting}

Translation of a $policySet$ (called $trans\_ps$ in listing ~\ref{lst:transps}), takes as input $e$, the environment, $ps$, the policy set, $prin_{u}$, the agreement's user, and $a$, the asset, and proceeds by case analysis of different policySet constructors and recursing into translation functions for the composing elements. A policySet is either a $PrimitivePolicySet$, $PrimitiveExclusivePolicySet$ or a $AndPolicySet$.  Note that to implement the translation for an $AndPolicySet$ a local function $trans_ps_list$ has been defined where for a single $policySet$, $trans_ps$ is called, and for a list of $policySet$s, the conjunction of $trans_ps$s are returned.

\lstset{language=Coq, frame=single, caption={Translation of Policy Set},label={lst:transps}}
\begin{minipage}{\linewidth}
\begin{lstlisting}

Fixpoint trans_ps
  (e:environment)(ps:policySet)(prin_u:prin)(a:asset){struct ps} : Prop :=

let trans_ps_list := (fix trans_ps_list (ps_list:nonemptylist policySet)(prin_u:prin)(a:asset){struct ps_list}:=
  match ps_list with
    | Single ps1 => trans_ps e ps1 prin_u a
    | NewList ps ps_list' => ((trans_ps e ps prin_u a) /\ (trans_ps_list ps_list' prin_u a))
  end) in
    match ps with
    | PrimitivePolicySet prq p => forall x, (((trans_prin x prin_u) /\ 
                                   (trans_preRequisite e x prq (getId p) prin_u)) -> 
                                   (trans_policy_positive e x p prin_u a))  

    | PrimitiveExclusivePolicySet prq p => forall x, ((((trans_prin x prin_u) /\ 
                                              (trans_preRequisite e x prq (getId p) prin_u)) -> 
                                             (trans_policy_positive e x p prin_u a)) /\
                                            ((not (trans_prin x prin_u)) -> (trans_policy_negative e x p a)))
                   
    | AndPolicySet ps_list => trans_ps_list ps_list prin_u a
    end.
\end{lstlisting}
\end{minipage}



% COQ
Translation of a \emph{prin} (called $trans\_prin$ in listing ~\ref{lst:transprin}) takes as input $x$, the $subject$ in question, $p$, the principal or the $prin$,  and proceeds based on whether $p$ is a single subject or a list of subjects. If $p$ is a single subject, $s$, the $Prop$ $x=s$ is returned. Otherwise the disjunction of the translation of the first subject in $p$ ($s$) and the $rest$ of the subjects is returned.

\lstset{language=Coq, frame=single, caption={Translation of a Prin},label={lst:transprin}}
\begin{lstlisting}

Fixpoint trans_prin
  (x:subject)(p: prin): Prop :=

  match p with
    | Single s => (x=s)
    | NewList s rest => ((x=s) \/ trans_prin x rest)
  end.
\end{lstlisting}


A positive translation for a policy (called $trans\_policy\_positive$ in listing ~\ref{lst:transpolicypositiveCoq}) takes as input $e$, the $environment$, $x$, the $subject$, $p$, the $policy$ to translate, $prin_{u}$, the agreement's user, and $a$, the asset and proceeds based on whether we have a $PrimitivePolicy$ or a $AndPolicy$. If the policy is a $PrimitivePolicy$ an implication is returned which indicates $x$ is \emph{permitted} to do $action$ to $a$, if the $preRequisite$ holds. 

$Permitted$ is a predicate specified as $Parameter Permitted : subject -> act -> asset -> Prop.$ So $Permitted$ predicate takes a $subject$, an $act$ (an action) and an $asset$ and returns a $Prop$. 

Note that to implement the translation for an $AndPolicy$ a local function $trans\_p\_list$ has been defined where for a single $policy$, $trans\_policy\_positive$ is returned, and for a list of $policy$s, the conjunction of $trans\_policy\_positive$s are returned.

\lstset{language=Coq, frame=single, caption={Translation of a positive policy},label={lst:transpolicypositiveCoq}}
\begin{lstlisting}

Fixpoint trans_policy_positive
  (e:environment)(x:subject)(p:policy)(prin_u:prin)(a:asset){struct p} : Prop :=

let trans_p_list := (fix trans_p_list (p_list:nonemptylist policy)(prin_u:prin)(a:asset){struct p_list}:=
                  match p_list with
                    | Single p1 => trans_policy_positive e x p1 prin_u a
                    | NewList p p_list' => 
                        ((trans_policy_positive e x p prin_u a) /\ 
                         (trans_p_list p_list' prin_u a))
                  end) in


  match p with
    | PrimitivePolicy prq policyId action => ((trans_preRequisite e x prq (Single policyId) prin_u) ->
                                              (Permitted x action a))
    | AndPolicy p_list => trans_p_list p_list prin_u a
  end.
\end{lstlisting}

A negative translation for a policy (called $trans\_policy\_negative$ in listing ~\ref{lst:transpolicynegativeCoq}) takes as input $e$, the $environment$, $x$, the $subject$, $p$, the $policy$ to translate, and $a$ the asset and proceeds based on whether we have a $PrimitivePolicy$ or a $AndPolicy$. If the policy is a $PrimitivePolicy$ an implication is returned which indicates $x$ is forbidden to do $action$ to $a$ regardless of whether $preRequisite$ holds. Note that the notation $(\lnot)$ indicates that $Permitted$ may be negated. As the case for the positive translation, to implement the translation for an $AndPolicy$ a local function $trans\_p\_list$ has been defined where for a single $policy$, $trans\_policy\_negative$ is returned, and for a list of $policy$s, the conjunction of $trans\_policy\_negative$s are returned.


\lstset{language=Coq, frame=single, caption={Translation of a negative policy},label={lst:transpolicynegativeCoq}}
\begin{lstlisting}

Fixpoint trans_policy_negative
  (e:environment)(x:subject)(p:policy)(a:asset){struct p} : Prop :=
let trans_p_list := (fix trans_p_list (p_list:nonemptylist policy)(a:asset){struct p_list}:=
                  match p_list with
                    | Single p1 => trans_policy_negative e x p1 a
                    | NewList p p_list' => ((trans_policy_negative e x p a) /\ 
                                            (trans_p_list p_list' a))
                  end) in


  match p with
    | PrimitivePolicy prq policyId action => not (Permitted x action a)
    | AndPolicy p_list => trans_p_list p_list a
  end.

\end{lstlisting}

The translation of a $prerequisite$ (called $trans\_preRequisite$ in listing ~\ref{lst:transpreRequisiteCoq}) takes as input $e$, the $environment$, $x$, the $subject$, $prq$, the $preRequisite$ to translate, $IDs$, the set of identifiers (of policies implied by the $prq$), $prin_{u}$, the agreement's user, and proceeds by case analysis on the structure of the $prerequisite$. A $prerequisite$ is either a $TruePrq$, a $Constraint$, a $ForEachMember$, a $NotCons$, a $AndPrqs$, a $OrPrqs$ or a $XorPrqs$. 

In listing ~\ref{lst:transpreRequisiteCoq} the translation for $TruePrq$ is the Prop $True$, the translations for $Constraint$, $ForEachMember$ and  $NotCons$ simply call respective translation functions for corresponding types $constraint$, $forEachMember$ and $constraint$ (namely $trans\_constraint$, $trans\_forEachMember$ and $trans\_notCons$). Note that the translation for $AndPrqs$, $OrPrqs$ and $XorPrqs$ have not yet been implemented but based on the their many-sorted-logic formulas' specifications (~\ref{lst:preRequisiteast}) they will be conjunctions, disjunctions and exclusive disjunctions of translations for each $prerequisite$.

\lstset{language=Coq, frame=single, caption={Translation of a PreRequisite},label={lst:transpreRequisiteCoq}}
\begin{lstlisting}

Definition trans_preRequisite
  (e:environment)(x:subject)(prq:preRequisite)(IDs:nonemptylist policyId)(prin_u:prin) : Prop := 

  match prq with
    | TruePrq => True
    | Constraint const => trans_constraint e x const IDs prin_u 
    | ForEachMember prn const_list => trans_forEachMember e x prn const_list IDs 
    | NotCons const => trans_notCons e x const IDs prin_u 
    | AndPrqs prqs => True 
    | OrPrqs prqs => True 
    | XorPrqs prqs => True 
  end.
\end{lstlisting}

The translation of a $constraint$ takes as input $e$, the $environment$, $x$, the $subject$ and $IDs$, the set of identifiers (of policies implied by the $constraint$) and proceeds by case analysis on the structure of the $constraint$. A $constraint$ is either a $Principal$, a $Count$ or a $CountByPrin$.

The Coq version of the translate function for a $constraint$ is given in ~\ref{lst:transconstraint}. 

\lstset{language=Coq, frame=single, caption={Translation of a Constraint},label={lst:transconstraint}}
\begin{lstlisting}

Fixpoint trans_constraint 
  (e:environment)(x:subject)(const:constraint)(IDs:nonemptylist policyId)
  (prin_u:prin){struct const} : Prop := 
  match const with
    | Principal prn => trans_prin x prn
  
    | Count n => trans_count e n IDs prin_u 

    | CountByPrin prn n => trans_count e n IDs prn 

  end.
  
\end{lstlisting}


The translation for $forEachMember$ yields a formula that is true, if each subject mentioned in $forEachMember$ is met by each constraint mentioned in $forEachMember$. Note that the agreement's user $prin_{u}$ maybe overriden by a $forEachConstraint$ constraint. 

\lstset{language=Coq, frame=single, caption={Translation of forEachMember},label={lst:transforEachMember}}
\begin{lstlisting}

Fixpoint trans_forEachMember
         (e:environment)(x:subject)(principals: nonemptylist subject)(const_list:nonemptylist constraint)
         (IDs:nonemptylist policyId){struct const_list} : Prop := 

let trans_forEachMember_Aux   
  := (fix trans_forEachMember_Aux
         (prins_and_constraints : nonemptylist (Twos subject constraint))
         (IDs:nonemptylist policyId){struct prins_and_constraints} : Prop :=

      match prins_and_constraints with
        | Single pair1 => trans_constraint e x (right pair1) IDs (Single (left pair1)) 
        | NewList pair1 rest_pairs =>
            (trans_constraint e x (right pair1) IDs (Single (left pair1))) /\
            (trans_forEachMember_Aux rest_pairs IDs)
      end) in

      let prins_and_constraints := process_two_lists principals const_list in
      trans_forEachMember_Aux prins_and_constraints IDs.

\end{lstlisting}


\lstset{language=Coq, frame=single, caption={Translation of not cons},label={lst:transnotCons}}
\begin{lstlisting}

Definition trans_notCons
  (e:environment)(x:subject)(const:constraint)(IDs:nonemptylist policyId)(prin_u:prin) : Prop :=
  ~ (trans_constraint e x const IDs prin_u).
\end{lstlisting}

\lstset{language=Coq, frame=single, caption={Translation of count},label={lst:transcount}}
\begin{lstlisting}
Fixpoint trans_count 
  (e:environment)(n:nat)(IDs:nonemptylist policyId)
  (prin_u:prin) : Prop := 

  let trans_count_aux 
    := (fix trans_count_aux
         (ids_and_subjects : nonemptylist (Twos policyId subject)) : nat :=
     match ids_and_subjects with
        | Single pair1 => getCount e (right pair1) (left pair1)
        | NewList pair1 rest_pairs =>
            (getCount e (right pair1)(left pair1)) +
            (trans_count_aux rest_pairs)
      end) in
  
  let ids_and_subjects := process_two_lists IDs prin_u in
  let running_total := trans_count_aux ids_and_subjects in
  running_total < n.
\end{lstlisting}

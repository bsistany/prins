%======================================================================
\chapter{Middle}
%======================================================================

%----------------------------------------------------------------------
\section{Logic Based Semantics for ODRL}
%----------------------------------------------------------------------

%See equation \ref{eqn_pi} on page \pageref{eqn_pi}.\footnote{A famous %equation.}

Formal logic can represent the statements and facts we express in a natural language like English. Propositional logic is expressive enough to express simple facts as propositions and allows uses connectives to allow for the negation, conjunction and disjunction of the facts. However propositional logic is not expressive enough to express policies of the kind used in languages like ODRL and XrML. For example, a simple policy expressed in English like ``All who pay 5 dollars can watch the movie Toy Story'' cannot be expressed in propositional logic because the concept of  variables doesn't exist. 

The higher order logic called ``Predicate Logic'' or ``First Order Logic'' \emph{FOL} is more suitable and has the expressive power to represent policies written in English. Moreover, FOL can be used to capture the meaning of policies in an unambiguous way.

Halpern and Weissman [Using First Order Logic to Reason about Policies] propose a fragment of FOL to represent and reason about policies. The fragment of FOL they arrive at is called \emph{Lithium} which is decidable and allows for efficiently answering interesting queries. Lithium restricts policies to be written based on the concept of ``bipolarity'' which disallows by construction policies that both permit and deny an action on an object.

\section{Pucella 2006}
Pucella and Weissman \cite{pucella2006} specify a predicate logic based based language that represents a subset of ODRL.

\section{what will I do?}


\subsection{Coq}


	• Program correctness
	• Formal verification of software
	• Certified programs
	• Proof assistant
	• Interactive and mechanized theorem proving
	• Examples of machine assisted proofs: CompCert, four-color theorem proof
	• Coq is based on a higher-order functional programming language
	• Dependent Types
		○ Subset types
		○ Easier than writing explicit proofs
	• Write formal specification and proofs that programs comply to their specification (a-short-intro-to-coq)
	• Automatically extract code from specifications as Ocaml or Haskell (a-short-intro)
	• Properties, programs and proofs are all formalized in the same language called CIC (Calculus of inductive Constructions). (a-short-intro)
	• Coq uses a sort called Prop for propositions
	• Coq art:
	• Well-formed propositions are assertions  one can express about values such as mathematical objects or even programs e.g. 3 < 8
		○ Note that assertions may be true, false or simply conjectures
		○ An assertion is only true in general if a proof is provided
		○ However hand written proofs are difficult to verify
		○ Coq provides an environment for developing proofs including a formal language to express proofs in, the language itself being built using proof theory making it possible to step by step verification of the proofs
		○ Mechanized proof verification requires a "proof" that the verification algorithm is correct itself in applying all the formal rules correctly







\section{Abstract Syntax}

\cite{pucella2006} uses abstract syntax instead of XML to express statements in the ODRL language. The abstract syntax used is a more compact representation than XML based language ODRL policies are written in and furthermore it simplifies specifying the semantics as we shall see. As an example here is an agreement written in ODRL and the comparable agreement expressed in the abstract syntax \cite{pucella2006}.

\lstset{language=XML}
\begin{lstlisting}[caption={agreement for Mary Smith in XML},label={lst:agreementxml}]
<agreement>
 <asset> <context> <uid> Treasure Island </uid> </context> </asset>
 <permission>
   <display>
    <constraint>
     <cpu> <context> <uid> Mary's computer </uid> </context> </cpu>
    </constraint>
   </display>
   <print>
    <constraint> <count> 2 </count> </constraint>
   </print>
  <requirement>
   <prepay>
    <payment> <amount currency="AUD"> 5.00</amount> </payment>
   </prepay>
  </requirement>
 </permission>
 <party> <context> <name> Mary Smith </name> </context> </party>
</agreement>
\end{lstlisting}

The agreement ~\ref{lst:agreementxml} is shown below using the syntax from \cite{pucella2006}.

\lstset{language=Pucella2006}
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}[frame=single, caption={agreement for Mary Smith as BNF (as used in ~\cite{pucella2006})},label={lst:agreementpucella2006}]
agreement
 for Mary Smith 
 about Treasure Island 
 with prePay[5.00] -> and[cpu[Mary's Computer] => display,
                                      count[2] => print].
\end{lstlisting}
\end{minipage} 

% \emph{prin\textsubscript{u}}
In the following we will cover the \emph{abstract syntax} of a subset of ODRL expressed as Coq's constructs such as \emph{Inductive Types} and Definitions. We will call this subset \emph{ODRL0} both because it is a variation of Pucella's ODRL language and also because it is missing some ODRL constructs such as \emph{Requirements} and \emph{Conditions} - we will add the missing pieces making up what we will call \emph{ODRL1} and perhaps \emph{ODRL2} (the latter only if needed). We will also describe ODRL0 in a \emph{BNF} grammar that looks more like Pucella's ODRL grammar. BNF style grammars are less formal as they give some suggestions about the surface syntax of expressions [Pierce1] without getting into lexical analysis and parsing related aspects such as precedence order of operators. The Coq version in contrast is more formal and could be directly used for building compilers and interpreters. We will present both the BNF version and the Coq version for each construct of ODRL0 [Pierce1]. To get started let's see what the listing ~\ref{lst:agreementpucella2006} would look like in ODRL0's Coq version.

\lstset{language=Coq}
\begin{lstlisting}[frame=single, caption={Coq version of agreement for Mary Smith},label={lst:marysmithagreementcoq}]

Agreement (Single MarySmith) Treasure Island 
 (PrimitivePolicySet (Constraint (PrePay 5.00))
  (AndPolicy 
   (NewList (PrimitivePolicy (Constraint 
                              (Principal 
                               (Single MarysComputer))) id1 Display)
   (Single (PrimitivePolicy (Constraint (Count 2)) id2 Print))))).
\end{lstlisting}


%\coqdoceol
%\coqdocvar{Agreement} (\coqdocvar{Single} \coqdocvar{Mary Smith}) \coqdocvar{Treasure Island} (\coqdocvar{PrimitivePolicySet} (\coqdocvar{Constraint} (\coqdocvar{PrePay} 5.00))\coqdoceol
%\coqdocindent{0.50em}
%(\coqdocvar{AndPolicy} (\coqdocvar{NewList} (\coqdocvar{PrimitivePolicy} (\coqdocvar{Constraint} (\coqdocvar{Principal} (\coqdocvar{Single} \coqdocvar{Mary's Computer}))) \coqdocvar{id1} \coqdocvar{Display})\coqdoceol
%\coqdocindent{6.00em}
%(\coqdocvar{Single} (\coqdocvar{PrimitivePolicy} (\coqdocvar{Constraint} (\coqdocvar{Count} 2)) \coqdocvar{id2} \coqdocvar{Print}))))).\coqdoceol
%\coqdocemptyline
%\coqdocemptyline

The top level ODRL0 production is the \emph{agreement}. An agreement expresses what actions a set of subjects may perform on an object and under what conditions. Syntactically an agreement is composed of a set of subjects/users called a \emph{principal} (\emph{prin}), an \emph{asset} and a \emph{Policy Set} (\emph{PolicySet}).

% agreement
\lstset{language=AST}
\begin{lstlisting}[frame=single, caption={agreement},label={lst:agreementast}]
<agreement> ::= 'agreement' 'for' <prin> 'about' <asset> 'with' <policySet> 
\end{lstlisting}

Principals or prins are composed of \emph{subjects} which are specified based on the application e.g. Alice, Bob, etc for the DRM application we will be using throughout.

% prin
\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={prin},label={lst:prinast}]
<prin> ::=  { <subject$_{1}$>, ..., <subject$_{m}$> }
\end{lstlisting}

% subject
\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={subject},label={lst:subjectast}]
<subject> ::= N
\end{lstlisting}

Assets are also application specific but similar to subjects we will use specific ones for the DRM application (taken from \cite{pucella2006}). \emph{ebook}, \emph{The Report} and \emph{latestJingle} are examples of specific subjects we will be using throughout. Syntactically an asset is just a positive number (\emph{N}).

% asset
\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={asset},label={lst:assetast}]
<asset> ::= N
\end{lstlisting}

Agreements include policy sets. Each policy set specifies a \emph{prerequisite} and a \emph{policy}. In general if the prerequisite holds the policy is taken into consideration. Otherwise the policy will not be looked at. Some policy sets are specified as \emph{exclusive}. The \emph{Primitive Exclusive Policy Sets} are exclusive to agreement's users in that only those users may perform the actions specified in the policy set. The implication is that all other users who are not specified in the agreement's principal (prin) are forbidden from performing the specified actions. Finally policy sets could be grouped together in a \emph{conjunction} allowing a single agreement to be associated with many policy sets. 


% policySet

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={policySet},label={lst:policySetast}]
<policySet> ::=  
	$\vert$ <PrimitivePolicySet> : <preRequisite> $\rightarrow$ <policy> 
	$\vert$ <PrimitiveExclusivePolicySet> : <preRequisite> $\mapsto$ <policy>	 
	$\vert$ <AndPolicySet> : 'and'[ <policySet$_{1}$>, ..., <policySet$_{m}$> ]
\end{lstlisting}

A policy specifies an action to be performed on an asset, depending of whether the policy's prerequisite holds or not. If the prerequisite holds the agreement's user is permitted to perform the action on the agreement's asset; otherwise permission is denied. Similar to policy sets, policies could also be grouped together in a conjunction. The policy also includes a unique identifier. The policy identifier is added to help the translation (from agreements to formulas) but is optional in ODRL proper.

% policy

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={policy},label={lst:policyast}]
<policy> ::=  
	$\vert$ <PrimitivePolicy> : <preRequisite> $\Rightarrow_{<policyId>}$ <act>
	$\vert$ <AndPolicy> : 'and'[ <policy$_{1}$>, ..., <policy$_{m}$> ]
\end{lstlisting}

An \emph{Action} (\emph{act}) is simply a positive number. Similar to assets and subjects, actions are application specific. Some example actions taken from \cite{pucella2006} are \emph{Display} and \emph{Print}.

% act
\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={act},label={lst:actast}]
<act> ::= N
\end{lstlisting}

A \emph{Policy Id} (\emph{policyId}) is a unique identifier specified as (increasing) positive integers. 

% id
\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={policyId},label={lst:policyIdast}]
<policyId> ::= N
\end{lstlisting}

In ODRL0 a \emph{prerequisite} is either true or it is a \emph{constraint}. The \emph{true} prerequisite always holds. A constraint is an intrinsic part of a policy and cannot be influenced by agreement's user. Minimum height requirements for popular attractions and rides are examples of we would consider a constraint. The constraint \emph{ForEachMember} is interesting in its expressive power but has complicated semantics as we shall see in the ~\ref{sec:Semantics} section. Roughly speaking, ForEachMember takes a prin (a list of subjects) and a list L of constraints. The ForEachConstraint holds if each subject in prin satisfies each constraint in L.\emph{NotCons} is a negation of a constraint. The set of prerequisites are closed under conjunction (\emph{AndPrqs}), disjunction (\emph{OrPrqs}) and exclusive disjunction (\emph{XorPrqs}).

% prq

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={preRequisite},label={lst:preRequisiteast}]
<preRequisite> ::=  
	$\vert$ <TruePrq> : 'True'
	$\vert$ <Constraint> : <constraint>	 
	$\vert$ <ForEachMember> : 'ForEachMember' [<prin> ; <constraint$_{1}$>, ..., <constraint$_{m}$> ]	
	$\vert$ <NotCons> : 'not' [ <constraint> ]
	$\vert$ <AndPrqs> : 'and'[ <preRequisite$_{1}$>, ..., <preRequisite$_{m}$> ]
	$\vert$ <OrPrqs> : 'or'[ <preRequisite$_{1}$>, ..., <preRequisite$_{m}$> ]
	$\vert$ <XorPrqs> : 'xor'[ <preRequisite$_{1}$>, ..., <preRequisite$_{m}$> ]		
\end{lstlisting}

Constraints are either \emph{Principal}, \emph{Count} or \emph{CountByPrin}. Principal constraints basically require matching to specified prins. For example, the user being Alice is a Principal constraint. A count constraint refers to a set of policies \emph{P} and specifies the number of times the user of an agreement has invoked the policies in P to justify her actions. If the count constraint is part of a policy then the set P is composed of the single policy. In the case that the count constraint is part of a policy set, the set P is the set of policies specified in the policy set.

% constraint
\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={constraint},label={lst:constraintast}]
<constraint> ::=  
	$\vert$ <Principal> : <prin>
	$\vert$ <Count> : 'Count' [N]
	$\vert$ <CountByPrin> : <prin> ('Count' [N])
\end{lstlisting}

% ---------------------------------- COQ -----------------------
\section{Coq Version}

\lstset{language=Coq}
\begin{lstlisting}[frame=single, caption={Coq version of agreement},label={lst:agreementcoq}]
Inductive agreement : Set :=
  | Agreement : prin -> asset -> policySet -> agreement.
\end{lstlisting}

% prin 
\lstset{language=Coq}
\begin{lstlisting}[frame=single, caption={prin},label={lst:princoq}]
Definition prin := nonemptylist subject.
\end{lstlisting}

% asset
\lstset{language=Coq}
\begin{lstlisting}[frame=single, caption={asset},label={lst:assetcoq}]
Definition asset := nat.
\end{lstlisting}



% subject
\lstset{language=Coq}
\begin{lstlisting}[frame=single, caption={subject},label={lst:subjectcoq}]
Definition subject := nat.
\end{lstlisting}


% policySet
\lstset{language=Coq}
\begin{lstlisting}[frame=single, caption={policySet},label={lst:policySetcoq}]
Inductive policySet : Set :=
  | PrimitivePolicySet : preRequisite -> policy -> policySet 
  | PrimitiveExclusivePolicySet : preRequisite -> policy  -> policySet 
  | AndPolicySet : nonemptylist policySet -> policySet.
\end{lstlisting}

% policy
\lstset{language=Coq}
\begin{lstlisting}[frame=single, caption={policy},label={lst:policycoq}]
Inductive policy : Set :=
  | PrimitivePolicy : preRequisite -> policyId -> act -> policy 
  | AndPolicy : nonemptylist policy -> policy.
\end{lstlisting}

% act
\lstset{language=Coq}
\begin{lstlisting}[frame=single, caption={act},label={lst:actcoq}]
Definition act := nat.
\end{lstlisting}

% id
\lstset{language=Coq}
\begin{lstlisting}[frame=single, caption={policyId},label={lst:policyIdcoq}]
Definition policyId := nat.
\end{lstlisting}

% prq
\lstset{language=Coq}
\begin{lstlisting}[frame=single, caption={preRequisite},label={lst:preRequisitecoq}]
Inductive preRequisite : Set :=
  | TruePrq : preRequisite
  | Constraint : constraint -> preRequisite 
  | ForEachMember : prin  -> nonemptylist constraint -> preRequisite
  | NotCons : constraint -> preRequisite 
  | AndPrqs : nonemptylist preRequisite -> preRequisite
  | OrPrqs : nonemptylist preRequisite -> preRequisite
  | XorPrqs : nonemptylist preRequisite -> preRequisite.
\end{lstlisting}

% constraint
\lstset{language=Coq}
\begin{lstlisting}[frame=single, caption={constraint},label={lst:constraintcoq}]
Inductive constraint : Set :=
  | Principal : prin  -> constraint 
  | Count : nat -> constraint 
  | CountByPrin : prin -> nat -> constraint.
\end{lstlisting}


%----------------------------------------------------------------------
\section{Semantics}
\label{sec:Semantics}

In this section, we describe the semantics of ODRL0 language by a translation from each language object (e.g. agreement) to a proposition in \emph{Coq}. The semantics will help answer queries of the form ``may subject \emph{s} perform action \emph{act} to asset \emph{a}?''. If the answer is yes, we say permission is granted. Otherwise permission is denied. 

Whether a permission is granted or denied depends on the agreements in question but also on the facts recorded in the environment. For ODRL0 those facts revolve around the number of times a policy has been used to justify an action. We encode this information in an \emph{environment} which is a conjunction of equalities of the form \emph{count(s, policyId) = n}. 

The Coq version of the count equality is a new inductive type called \emph{count_equality}. An environment is defined to be a non-empty list of count_equality objects.

\lstset{language=Coq, frame=single, caption={Environments and Counts},label={lst:environmentcoq}}
\begin{lstlisting}
Inductive count_equality : Set := 
   | CountEquality : subject -> policyId -> nat -> count_equality.

Inductive environment : Set := 
  | SingleEnv : count_equality -> environment
  | ConsEnv :  count_equality ->  environment -> environment.

\end{lstlisting}

At a high-level, an agreement is translated into a conjunction of formulas of the form $\forall x ( prerequisites(x) \rightarrow P(x))$ where $P(x)$ itself is a conjunction of formulas of the form $ prerequisites(x) \rightarrow (\lnot) Permitted (x, act, a)$, where $x$ is a variable of type $subject$ that occurs free in $P(x)$, $act$ is an action, $a$ is an asset and lastly $Permitted$ is a \emph{predicate}. A predicate in Coq is any function that returns a term of type \emph{Prop}. Here is how we have specified the $Permitted$ predicate in Coq: $Parameter Permitted : subject -> act -> asset -> Prop.$ So $Permitted$ predicate takes a $subject$, an $act$ (action) and an $asset$ and returns a $Prop$. Note that the notation $(\lnot)$ indicates that $Permitted$ may be negated.

Translation of the top level $agreement$ element proceeds by case analysis on the structure of the agreement. Note that each translation function takes an environment parameter.


\lstset{language=Coq, frame=single, caption={Translation of agreement},label={lst:transagreement}}
\begin{lstlisting}

Definition trans_agreement (e:environment)(ag:agreement) : Prop :=
  match ag with 
    | Agreement prin_u a ps => trans_ps e ps prin_u a
  end.

\end{lstlisting}

Translation of a $policySet$ takes as input $prin_{u}$, the agreement's user, and $a$, the asset, and proceeds by case analysis of different policySet constructors and recursing into translation functions for the composing elements. A policySet is either a $PrimitivePolicySet$, $PrimitiveExclusivePolicySet$ or a $AndPolicySet$. 

Translation of a $PrimitivePolicySet$ ($preRequisite \rightarrow policy$) yields an implication. Basically, if the user is in $prin_{u}$ and the pre-requisite holds, the policy holds.

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Policy Set Translation {$\colon$} PrimitivePolicySet},label={lst:transpolicyformulaPrimitivePolicySet}]
$[\![ preRequisite \rightarrow policy]\!]^{e, prin_{u}, a}$ $\triangleq$ $\forall x$ $(\!( [\![prin_{u}]\!]_{x}$ $\land$ $[\![preRequisite]\!]^{e, getId (p), prin_{u}, a}_{x}) \rightarrow [\![policy]\!]^{positive, e, prin_{u}, a}_{x}             \!)$
\end{lstlisting}

$PrimitiveExclusivePolicySet$ ($preRequisite \mapsto policy$) yields an implication, similar to the translation of a $PrimitivePolicySet$ except we use a second implication to restrict access (to make the policy set exclusive) to only those subjects that are in the agreement's user. As we shall see later the policy's prerequisites will not override the exclusivity of this type of policy set.

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Policy Set Translation {$\colon$} PrimitiveExclusivePolicySet},label={lst:transpolicyformulaPrimitiveExclusivePolicySet}]
$[\![ preRequisite \mapsto policy]\!]^{e, prin_{u}, a}$ $\triangleq$ $\forall x$ $(\!( [\![prin_{u}]\!]_{x}$ $\land$ $[\![preRequisite]\!]^{e, getId (p), prin_{u}, a}_{x}) \rightarrow [\![policy]\!]^{positive, e, prin_{u}, a}_{x}\!)$ $\land$ $\forall x$ $(\neg[\![prin_{u}]\!]_{x} \rightarrow [\![policy]\!]^{negative, e, a}_{x})$
\end{lstlisting}

$AndPolicySet$ translates to conjunctions of the corresponding policy set translations. 

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Policy Set Translation {$\colon$} AndPolicySet},label={lst:transpolicyformulaAndPolicySet}]
$[\![ and [policySet_{1}, ..., policySet_{m}]]\!]^{e, prin_{u}, a}$ $\triangleq$ $[\![policySet_{1}]\!]^{e, prin_{u}, a}$ $\land$ $...$ $\land$ $[\![policySet_{m}]\!]^{e, prin_{u}, a}$

\end{lstlisting}

The Coq version of the policy set translation function follows (listing ~\ref{lst:transps}).

\lstset{language=Coq, frame=single, caption={Translation of Policy Set},label={lst:transps}}
\begin{minipage}{\linewidth}
\begin{lstlisting}

Fixpoint trans_ps
  (e:environment)(ps:policySet)(prin_u:prin)(a:asset){struct ps} : Prop :=

let trans_ps_list := (fix trans_ps_list (ps_list:nonemptylist policySet)(prin_u:prin)(a:asset){struct ps_list}:=
  match ps_list with
    | Single ps1 => trans_ps e ps1 prin_u a
    | NewList ps ps_list' => ((trans_ps e ps prin_u a) /\ (trans_ps_list ps_list' prin_u a))
  end) in
    match ps with
    | PrimitivePolicySet prq p => forall x, (((trans_prin x prin_u) /\ 
                                   (trans_preRequisite e x prq (getId p) prin_u)) -> 
                                   (trans_policy_positive e x p prin_u a))  

    | PrimitiveExclusivePolicySet prq p => forall x, ((((trans_prin x prin_u) /\ 
                                              (trans_preRequisite e x prq (getId p) prin_u)) -> 
                                             (trans_policy_positive e x p prin_u a)) /\
                                            ((not (trans_prin x prin_u)) -> (trans_policy_negative e x p a)))
                   
    | AndPolicySet ps_list => trans_ps_list ps_list prin_u a
    end.
\end{lstlisting}
\end{minipage}

Translation of a \emph{prin_{u}} takes as input $x$, a variable of type $subject$ and proceeds based on whether we have a single subject or a list of subjects.  

Translation of a single $prin_{u}$ yields a formula that is true if and only if the subject $x$ is the same as the single subject.

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Prin Translation {$\colon$} Single subject},label={lst:transprinSingle}]
$[\![ subject ]\!]_{x}$ $\triangleq$ $x=subject$
\end{lstlisting}


Translation of a list of subjects is the conjunction of the translations of each subject.

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Prin Translation {$\colon$} List of subjects},label={lst:transprinListOfSubjects}]

$[\![ \{ subject_{1}, ..., subject_{m} \} ]\!]_{x}$ $\triangleq$ $[\![subject_{1}]\!]_{x}$ $\lor$ $...$ $\lor$ $[\![subject_{m}]\!]_{x}$

\end{lstlisting}

\lstset{language=Coq, frame=single, caption={Translation of a Prin},label={lst:transprin}}
\begin{lstlisting}

Fixpoint trans_prin
  (x:subject)(p: prin): Prop :=

  match p with
    | Single s => (x=s)
    | NewList s rest => ((x=s) \/ trans_prin x rest)
  end.
\end{lstlisting}


Depending on whether a permission is granted or not we define two translations for policies. A positive translation and a negatives one. 

A positive translation for a policy $p$ takes as input $e$, the $environment$, $x$, the $subject$, $prin_{u}$, the agreement's user, and $a$, the asset and proceeds based on whether we have a $PrimitivePolicy$ or a $AndPolicy$. If the policy is a $PrimitivePolicy$ an implication is returned which indicates $x$ is permitted to do $act$ to $a$, if the $preRequisite$ holds.


\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Positive Policy Translation {$\colon$} Single policy},label={lst:transpolicypositiveSingle}]

$[\![ preRequisite \Rightarrow_{policyId} act ]\!]^{positive, e, prin_{u}, a}_{x}$ $\triangleq$ $([\![ preRequisite ]\!]^{e, policyId, prin_{u}}_{x}) \Rightarrow Permitted(x, [\![act]\!], a)$

\end{lstlisting}

If the policy is a $AndPolicy$, the translation yields a conjunction of positive translations of each policy in turn.

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Positive Policy Translation {$\colon$} List of policies},label={lst:transpolicypositiveListOfPolicies}]

$[\![ and [policy_{1}, ..., policy_{m}]]\!]^{positive, e, prin_{u}, a}$ $\triangleq$ $[\![policy_{1}]\!]^{positive, e, prin_{u}, a}$ $\land$ $...$ $\land$ $[\![policy_{m}]\!]^{positive, e, prin_{u}, a}$

\end{lstlisting}



\lstset{language=Coq, frame=single, caption={Translation of a positive policy},label={lst:transpolicypositiveCoq}}
\begin{lstlisting}

Fixpoint trans_policy_positive
  (e:environment)(x:subject)(p:policy)(prin_u:prin)(a:asset){struct p} : Prop :=

let trans_p_list := (fix trans_p_list (p_list:nonemptylist policy)(prin_u:prin)(a:asset){struct p_list}:=
                  match p_list with
                    | Single p1 => trans_policy_positive e x p1 prin_u a
                    | NewList p p_list' => 
                        ((trans_policy_positive e x p prin_u a) /\ 
                         (trans_p_list p_list' prin_u a))
                  end) in


  match p with
    | PrimitivePolicy prq policyId action => ((trans_preRequisite e x prq (Single policyId) prin_u) ->
                                              (Permitted x action a))
    | AndPolicy p_list => trans_p_list p_list prin_u a
  end.
\end{lstlisting}


A negative translation for a policy $p$ takes as input $e$, the $environment$, $x$, the $subject$, $prin_{u}$, the agreement's user, and $a$, the asset and proceeds based on whether we have a $PrimitivePolicy$ or a $AndPolicy$. If the policy is a $PrimitivePolicy$ an implication is returned which indicates $x$ is forbidden to do $act$ to $a$ regardless of whether $preRequisite$ holds.


\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Negative Policy Translation {$\colon$} Single policy},label={lst:transpolicynegativeSingle}]

$[\![ preRequisite \Rightarrow_{policyId} act ]\!]^{negative, e, prin_{u}, a}_{x}$ $\triangleq$ $([\![ preRequisite ]\!]^{e, policyId, prin_{u}}_{x}) \Rightarrow \lnot (Permitted(x, [\![act]\!], a))$
\end{lstlisting}

If the policy is a $AndPolicy$, the translation yields a conjunction of negative translations of each policy in turn.

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Negative Policy Translation {$\colon$} List of policies},label={lst:transpolicynegativeListOfPolicies}]

$[\![ and [policy_{1}, ..., policy_{m}]]\!]^{negative, e, a}$ $\triangleq$ $[\![policy_{1}]\!]^{negative, e, a}$ $\land$ $...$ $\land$ $[\![policy_{m}]\!]^{negative, e, a}$


\end{lstlisting}

\lstset{language=Coq, frame=single, caption={Translation of a negative policy},label={lst:transpolicynegative}}
\begin{lstlisting}

Fixpoint trans_policy_negative
  (e:environment)(x:subject)(p:policy)(a:asset){struct p} : Prop :=
let trans_p_list := (fix trans_p_list (p_list:nonemptylist policy)(a:asset){struct p_list}:=
                  match p_list with
                    | Single p1 => trans_policy_negative e x p1 a
                    | NewList p p_list' => ((trans_policy_negative e x p a) /\ 
                                            (trans_p_list p_list' a))
                  end) in


  match p with
    | PrimitivePolicy prq policyId action => not (Permitted x action a)
    | AndPolicy p_list => trans_p_list p_list a
  end.

\end{lstlisting}

The translation of a $prerequisite$ takes as input $e$, the $environment$, $x$, the $subject$, $prin_{u}$, the agreement's user, and $IDs$, the set of identifiers (of policies implied by the $prerequisite$) and proceeds by case analysis on the structure of the $prerequisite$. A $prerequisite$ is either a $TruePrq$, a $Constraint$, a $ForEachMember$, a $NotCons$, a $AndPrqs$, a $OrPrqs$ or a $XorPrqs$.

The translation for a $TruePrq$ yields a formula that is always \emph{true}.

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Prerequisite Translation {$\colon$} Always True Prerequisite},label={lst:transpreRequisiteTruePrq}]
	$[\![ prerequisite::true ]\!]$ $\triangleq$ True
\end{lstlisting}

The translation for a $Constraint$ is handled by a specialized constraint translation function (coverage of which starts at ~\ref{lst:transconstraintPrin}.

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Prerequisite Translation {$\colon$} Constraint},label={lst:transpreRequisiteConstraint}]

$[\![ prerequisite::constraint ]\!]^{[id_{1}, ..., id_{m}], prin_{u}}_{x}$ $\triangleq$ $[\![ constraint ]\!]^{[id_{1}, ..., id_{m}], prin_{u}}_{x}$ 
\end{lstlisting}

The translation for a $ForEachMember$ is also is handled by a specialized translation function (covered at ~\ref{lst:transforEachMember}.

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Prerequisite Translation {$\colon$} ForEachMember},label={lst:transpreRequisiteForEachMember}]

$[\![ prerequisite::forEachMember ]\!]^{[subject_{1}, ..., subject_{k}], [constraint_{1}, ..., constraint_{m}], [id_{1}, ..., id_{n}]}_{x}$ $\triangleq$ $[\![ forEachMember ]\!]^{[subject_{1}, ..., subject_{k}], [constraint_{1}, ..., constraint_{m}], [id_{1}, ..., id_{n}]}_{x}$ 	
\end{lstlisting}

The translation for a $NotCons$ yields a formula that is simply the negation of the translation for a constraint.

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Prerequisite Translation {$\colon$} Not Constraint},label={lst:transpreRequisiteNotConstraint}]

$[\![ not$ $prerequisite::constraint ]\!]^{[id_{1}, ..., id_{m}], prin_{u}}_{x}$ $\triangleq$ $\lnot[\![ constraint ]\!]^{[id_{1}, ..., id_{m}], prin_{u}}_{x}$ 
\end{lstlisting}

The translation for a $AndPrqs$ yields a formula that is the conjunction of the translation for each $preRequisite$.

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Prerequisite Translation {$\colon$} Conjunction },label={lst:transpreRequisiteAndPrqs}]

$[\![and$ $[preRequisite_{1}, ..., preRequisite_{k}]]\!]^{[id_{1}, ..., id_{m}], prin_{u}}$ $\triangleq$ $[\![preRequisite_{1}]\!]^{[id_{1}, ..., id_{m}], prin_{u}}$ $\land$ $...$ $\land$ $[\![preRequisite_{k}]\!]^{[id_{1}, ..., id_{m}], prin_{u}}$

\end{lstlisting}

The translation for a $OrPrqs$ yields a formula that is the inclusive disjunction of the translation for each $preRequisite$.

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Prerequisite Translation {$\colon$} Inclusive Disjunction},label={lst:transpreRequisiteOrPrqs}]

$[\![or$ $[preRequisite_{1}, ..., preRequisite_{k}]]\!]^{[id_{1}, ..., id_{m}], prin_{u}}$ $\triangleq$ $[\![preRequisite_{1}]\!]^{[id_{1}, ..., id_{m}], prin_{u}}$ $\lor$ $...$ $\lor$ $[\![preRequisite_{k}]\!]^{[id_{1}, ..., id_{m}], prin_{u}}$

\end{lstlisting}

The translation for a $XorPrqs$ yields a formula that is the exclusive disjunction of the translation for each $preRequisite$.


\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Prerequisite Translation {$\colon$} Exclusive Disjunction},label={lst:transpreRequisiteXorPrqs}]

$[\![Xor$ $[preRequisite_{1}, ..., preRequisite_{k}]]\!]^{[id_{1}, ..., id_{m}], prin_{u}}$ $\triangleq$ $[\![preRequisite_{1}]\!]^{[id_{1}, ..., id_{m}], prin_{u}}$ $\oplus $ $...$ $\oplus$ $[\![preRequisite_{k}]\!]^{[id_{1}, ..., id_{m}], prin_{u}}$

\end{lstlisting}

The Coq version of the translate function for a $preRequisite$ is given in ~\ref{lst:transpreRequisite}. Note that in this listing the translations for $AndPrqs$, $OrPrqs$ and $XorPrqs$ have not yet been done.

\lstset{language=Coq, frame=single, caption={Translation of a PreRequisite},label={lst:transpreRequisite}}
\begin{lstlisting}

Definition trans_preRequisite
  (e:environment)(x:subject)(prq:preRequisite)(IDs:nonemptylist policyId)(prin_u:prin) : Prop := 

  match prq with
    | TruePrq => True
    | Constraint const => trans_constraint e x const IDs prin_u 
    | ForEachMember prn const_list => trans_forEachMember e x prn const_list IDs 
    | NotCons const => trans_notCons e x const IDs prin_u 
    | AndPrqs prqs => True 
    | OrPrqs prqs => True 
    | XorPrqs prqs => True 
  end.
\end{lstlisting}



The translation of a $constraint$ takes as input $e$, the $environment$, $x$, the $subject$ and $IDs$, the set of identifiers (of policies implied by the $constraint$) and proceeds by case analysis on the structure of the $constraint$. A $constraint$ is either a $Principal$, a $Count$ or a $CountByPrin$.

The translation for a $Principal$ is handled by a specialized translation function (covered at ~\ref{lst:transprin}.   

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Constraint Translation {$\colon$} Principal},label={lst:transconstraintPrin}]

$[\![ constraint::prin ]\!]^{[subject_{1}, ..., subject_{m}]}_{x}$ $\triangleq$ $[\![ prin ]\!]^{[subject_{1}, ..., subject_{m}]}_{x}$ 
\end{lstlisting}

The translation for a $Count$ is handled by a specialized translation function (covered at ~\ref{lst:transcount}.

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Constraint Translation {$\colon$} Count},label={lst:transconstraintCount}]

$[\![ constraint::count [N] ]\!]^{[id_{1}, ..., id_{m}], prin_{u}}_{x}$ $\triangleq$ $[\![ count [N] ]\!]^{[id_{1}, ..., id_{m}], prin_{u}}_{x}$ 
\end{lstlisting}

The translation for a $CountByPrin$ is handled by the same specialized translation function as that for $Count$. The difference is that $CountByPrin$ overrides the subjects in $prin_{u}$ by a different set of subjects (covered at ~\ref{lst:transcount}.

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Constraint Translation {$\colon$} Count by Principal},label={lst:transconstraintCountbyPrin}]

$[\![ constraint::prin(count [N]) ]\!]^{[subject_{1}, ..., subject_{m}], [id_{1}, ..., id_{n}]}_{x}$ $\triangleq$ $[\![ prin(count [N]) ]\!]^{[subject_{1}, ..., subject_{m}], [id_{1}, ..., id_{n}]}_{x}$ 
\end{lstlisting}

The Coq version of the translate function for a $constraint$ is given in ~\ref{lst:transconstraint}. 

\lstset{language=Coq, frame=single, caption={Translation of a Constraint},label={lst:transconstraint}}
\begin{lstlisting}

Fixpoint trans_constraint 
  (e:environment)(x:subject)(const:constraint)(IDs:nonemptylist policyId)
  (prin_u:prin){struct const} : Prop := 
  match const with
    | Principal prn => trans_prin x prn
  
    | Count n => trans_count e n IDs prin_u 

    | CountByPrin prn n => trans_count e n IDs prn 

  end.
  
\end{lstlisting}


The translation for $forEachMember$ yields a formula that is true, if each subject mentioned in $forEachMember$ is met by each constraint mentioned in $forEachMember$. Note that the agreement's user $prin_{u}$ maybe overriden by a $forEachConstraint$ constraint. 


\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={ForEachMember Translation {$\colon$} Count by Principal},label={lst:transforEachMember}]

$[\![ forEachMember ]\!]^{[subject_{1}, ..., subject_{k}], [constraint_{1}, ..., constraint_{m}], [id_{1}, ..., id_{n}]}_{x}$ $\triangleq$ $[\![constraint]\!]^{(subject_{1}, constraint_{1}), [id_{1}, ..., id_{n}]}_{x}$ $\land$ $...$ $\land$ $[\![constraint]\!]^{(subject_{1}, constraint_{m}), [id_{1}, ..., id_{n}]}_{x}$ $\land$ $...$ $\land$ $[\![constraint]\!]^{(subject_{2}, constraint_{1}), [id_{1}, ..., id_{n}]}_{x}$ $\land$ $...$ $\land$ $[\![constraint]\!]^{(subject_{2}, constraint_{m}), [id_{1}, ..., id_{n}]}_{x}$ $\land$ $...$ $\land$ $[\![constraint]\!]^{(subject_{k}, constraint_{1}), [id_{1}, ..., id_{n}]}_{x}$ $\land$ $...$ $\land$ $[\![constraint]\!]^{(subject_{k}, constraint_{m}), [id_{1}, ..., id_{n}]}_{x}$ 

\end{lstlisting}

\lstset{language=Coq, frame=single, caption={Translation of forEachMember},label={lst:transforEachMember}}
\begin{lstlisting}

Fixpoint trans_forEachMember
         (e:environment)(x:subject)(principals: nonemptylist subject)(const_list:nonemptylist constraint)
         (IDs:nonemptylist policyId){struct const_list} : Prop := 

let trans_forEachMember_Aux   
  := (fix trans_forEachMember_Aux
         (prins_and_constraints : nonemptylist (Twos subject constraint))
         (IDs:nonemptylist policyId){struct prins_and_constraints} : Prop :=

      match prins_and_constraints with
        | Single pair1 => trans_constraint e x (right pair1) IDs (Single (left pair1)) 
        | NewList pair1 rest_pairs =>
            (trans_constraint e x (right pair1) IDs (Single (left pair1))) /\
            (trans_forEachMember_Aux rest_pairs IDs)
      end) in

      let prins_and_constraints := process_two_lists principals const_list in
      trans_forEachMember_Aux prins_and_constraints IDs.

\end{lstlisting}


The translation for ``Not Constraint'' was listed in listing ~\ref{lst:transpreRequisiteNotConstraint} earlier but we repeat it here to go along the Coq version. 

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Not Constraint Translation},label={lst:transnotCons}]

$[\![ not$ $constraint ]\!]^{[id_{1}, ..., id_{m}], prin_{u}}_{x}$ $\triangleq$ $\lnot[\![ constraint ]\!]^{[id_{1}, ..., id_{m}], prin_{u}}_{x}$ 

\end{lstlisting}

\lstset{language=Coq, frame=single, caption={Translation of not cons},label={lst:transnotCons}}
\begin{lstlisting}

Definition trans_notCons
  (e:environment)(x:subject)(const:constraint)(IDs:nonemptylist policyId)(prin_u:prin) : Prop :=
  ~ (trans_constraint e x const IDs prin_u).
\end{lstlisting}

The translation for $Count$ or $CountByPrin$ for a pair of subject and policy identifier is a formula that is true if the number of times the $subject_{1}$ has invoked a policy with policy identifier $id_{1}$ is smaller than $N$.

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Count Translation {$\colon$} subject and policyId pair},label={lst:transcountSinglePair}]

$[\![ count [N] ]\!]^{subject_{1}, id_{1}}_{x}$ $\triangleq$ $getCount(subject_{1}, id_{1}) < N$
\end{lstlisting}

The translation for $Count$ or $CountByPrin$ for subject and policy identifier pairs is a formula that is true if the total number of times that a subject has invoked a policy with policy identifier $id_{i}$ is smaller than $N$.

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Count Translation {$\colon$} subject and policyId pairs},label={lst:transcountPairs}]

$[\![ count [N] ]\!]^{[id_{1}, ..., id_{m}], prn}_{x}$ $\triangleq$ 

$(getCount(getSubject(prn)_{1}, id_{1})$ $+ ... +$ $getCount(getSubject(prn)_{1}, id_{m})$ $+ ... +$ $getCount(getSubject(prn)_{k}, id_{1})$ $+ ... +$ $getCount(getSubject(prn)_{k}, id_{m}))$ < $N$


\end{lstlisting}




\lstset{language=Coq, frame=single, caption={Translation of count},label={lst:transcount}}
\begin{lstlisting}
Fixpoint trans_count 
  (e:environment)(n:nat)(IDs:nonemptylist policyId)
  (prin_u:prin) : Prop := 

  let trans_count_aux 
    := (fix trans_count_aux
         (ids_and_subjects : nonemptylist (Twos policyId subject)) : nat :=
     match ids_and_subjects with
        | Single pair1 => getCount e (right pair1) (left pair1)
        | NewList pair1 rest_pairs =>
            (getCount e (right pair1)(left pair1)) +
            (trans_count_aux rest_pairs)
      end) in
  
  let ids_and_subjects := process_two_lists IDs prin_u in
  let running_total := trans_count_aux ids_and_subjects in
  running_total < n.
\end{lstlisting}
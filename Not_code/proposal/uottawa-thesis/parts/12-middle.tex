%======================================================================
\chapter{Middle}
%======================================================================

%----------------------------------------------------------------------
\section{Logic Based Semantics for ODRL}
%----------------------------------------------------------------------

%See equation \ref{eqn_pi} on page \pageref{eqn_pi}.\footnote{A famous %equation.}

Formal logic can represent the statements and facts we express in a natural language like English. Propositional logic is expressive enough to express simple facts as propositions and uses connectives to allow for the negation, conjunction and disjunction of the facts. However propositional logic is not expressive enough to express policies of the kind used in languages like ODRL and XrML. For example, a simple policy expressed in English like ``All who pay 5 dollars can watch the movie Toy Story'' cannot be expressed in propositional logic because the concept of  variables doesn't exist in propositional logic. 

A richer logic called ``Predicate Logic'' or ``First Order Logic'' (\emph{FOL}) is more suitable and has the expressive power to represent policies written in English. Moreover, FOL can be used to capture the meaning of policies in an unambiguous way.

Halpern and Weissman [Using First Order Logic to Reason about Policies] propose a fragment of FOL to represent and reason about policies. The fragment of FOL they arrive at is called \emph{Lithium} which is decidable and allows for efficiently answering interesting queries. Lithium restricts policies to be written based on the concept of ``bipolarity'' which disallows by construction policies that both permit and deny an action on an object.

\section{Pucella 2006}
Pucella and Weissman \cite{pucella2006} specify a predicate logic based based language that represents a subset of ODRL.

\section{what will I do?}


\subsection{Coq}


	• Program correctness
	• Formal verification of software
	• Certified programs
	• Proof assistant
	• Interactive and mechanized theorem proving
	• Examples of machine assisted proofs: CompCert, four-color theorem proof
	• Coq is based on a higher-order functional programming language
	• Dependent Types
		○ Subset types
		○ Easier than writing explicit proofs
	• Write formal specification and proofs that programs comply to their specification (a-short-intro-to-coq)
	• Automatically extract code from specifications as Ocaml or Haskell (a-short-intro)
	• Properties, programs and proofs are all formalized in the same language called CIC (Calculus of inductive Constructions). (a-short-intro)
	• Coq uses a sort called Prop for propositions
	• Coq art:
	• Well-formed propositions are assertions  one can express about values such as mathematical objects or even programs e.g. 3 < 8
		○ Note that assertions may be true, false or simply conjectures
		○ An assertion is only true in general if a proof is provided
		○ However hand written proofs are difficult to verify
		○ Coq provides an environment for developing proofs including a formal language to express proofs in, the language itself being built using proof theory making it possible to step by step verification of the proofs
		○ Mechanized proof verification requires a "proof" that the verification algorithm is correct itself in applying all the formal rules correctly





                  
%----------------------------------------------------------------------
\section{Semantics}
\label{sec:Semantics}

In this section, we describe the semantics of ODRL0 language by a translation from agreements to a subset of many-sorted first-order logic formulas with equality. The semantics will help answer queries of the form ``may subject \emph{s} perform action \emph{act} to asset \emph{a}?''. If the answer is yes, we say permission is granted. Otherwise permission is denied. 


At a high-level, an agreement is translated into a conjunction of formulas of the form $\forall x ( prerequisites(x) \rightarrow P(x))$ where $P(x)$ itself is a conjunction of formulas of the form $ prerequisites(x) \rightarrow (\lnot) Permitted (x, act, a)$, where ``Permitted (x, act, a)'' means the subject $x$ is permitted to perform action $act$ on asset $a$.

\subsection{Agreement Translation}
The translation of an $agreement$ returns the translation for a $policySet$ per $prin_{u}$, the agreement's user and $a$, the asset.


\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Agreement Translation},label={lst:transAgreementast}]
$[\![ agreement$ $for$ $prin_{u}$ $about$ $a$ $with$ $ps]\!]$ $\triangleq$ $[\![policySet]\!]^{prin_{u}, a}$
\end{lstlisting}

\subsection{Policy Set Translation}
The translation for a $policySet$ ($[\![policySet]\!]^{prin_{u}, a}$) is described by translation formulas for each type of $policySet$. A $policySet$ is either a $PrimitivePolicySet$, a $\linebreak PrimitiveExclusivePolicySet$ or a $AndPolicySet$.

\subsubsection{PrimitivePolicySet Translation}
Translation of a $PrimitivePolicySet$ ($preRequisite \rightarrow policy$) yields a formula that includes a test on whether the subject is in the set of agreements' users, the translation of the policy and the translation of the $prerequisite$. Basically if the subject in question is a user of the agreement and the policySet prerequisites hold, then the policy holds. Translation of the policy for a $PrimitivePolicySet$ is called a \emph{positive translation}. A positive translation is one where the actions described by the policies are permitted.   

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Policy Set Translation {$\colon$} PrimitivePolicySet},label={lst:transpolicyformulaPrimitivePolicySet}]
$[\![ preRequisite \rightarrow policy]\!]^{e, prin_{u}, a}$ $\triangleq$ $\forall x$ $(\!( [\![prin_{u}]\!]_{x}$ $\land$ $[\![preRequisite]\!]^{e, getId (p), prin_{u}, a}_{x}) \rightarrow [\![policy]\!]^{positive, e, prin_{u}, a}_{x}\!)$
\end{lstlisting}



\lstset{mathescape, language=AST} 
\begin{lstlisting}[frame=single, caption={Positive Policy Translation {$\colon$} Single policy},label={lst:transpolicypositiveSingle}]

$[\![ preRequisite \Rightarrow_{policyId} act ]\!]^{positive, e, prin_{u}, a}_{x}$ $\triangleq$ $([\![ preRequisite ]\!]^{e, policyId, prin_{u}}_{x}) \Rightarrow Permitted(x, [\![act]\!], a)$

\end{lstlisting}


If the policy is a $AndPolicy$, the translation yields a conjunction of positive translations of each policy in turn.

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Positive Policy Translation {$\colon$} List of policies},label={lst:transpolicypositiveListOfPolicies}]

$[\![ and [policy_{1}, ..., policy_{m}]]\!]^{positive, e, prin_{u}, a}$ $\triangleq$ $[\![policy_{1}]\!]^{positive, e, prin_{u}, a}$ $\land$ $...$ $\land$ $[\![policy_{m}]\!]^{positive, e, prin_{u}, a}$

\end{lstlisting}


\subsubsection{PrimitiveExclusivePolicySet Translation}
$PrimitiveExclusivePolicySet$ ($preRequisite \mapsto policy$) yields the conjunction of two implications. The first implication, is the same as one found in the translation of $PrimitivePolicySet$. The second implication however restricts access (to make the policy set exclusive) to only those subjects that are in the agreement's user. Translation of the policy in the second implication is called a \emph{negative translation}. A negative translation is one where the actions described by the policies are not permitted. 


\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Policy Set Translation {$\colon$} PrimitiveExclusivePolicySet},label={lst:transpolicyformulaPrimitiveExclusivePolicySet}]
$[\![ preRequisite \mapsto policy]\!]^{e, prin_{u}, a}$ $\triangleq$ $\forall x$ $(\!( [\![prin_{u}]\!]_{x}$ $\land$ $[\![preRequisite]\!]^{e, getId (p), prin_{u}, a}_{x}) \rightarrow [\![policy]\!]^{positive, e, prin_{u}, a}_{x}\!)$ $\land$ $\forall x$ $(\neg[\![prin_{u}]\!]_{x} \rightarrow [\![policy]\!]^{negative, e, a}_{x})$
\end{lstlisting}


\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Negative Policy Translation {$\colon$} Single policy},label={lst:transpolicynegativeSingle}]

$[\![ preRequisite \Rightarrow_{policyId} act ]\!]^{negative, e, prin_{u}, a}_{x}$ $\triangleq$ $([\![ preRequisite ]\!]^{e, policyId, prin_{u}}_{x}) \Rightarrow \lnot (Permitted(x, [\![act]\!], a))$
\end{lstlisting}

If the policy is a $AndPolicy$, the translation yields a conjunction of negative translations of each policy in turn.

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Negative Policy Translation {$\colon$} List of policies},label={lst:transpolicynegativeListOfPolicies}]

$[\![ and [policy_{1}, ..., policy_{m}]]\!]^{negative, e, a}$ $\triangleq$ $[\![policy_{1}]\!]^{negative, e, a}$ $\land$ $...$ $\land$ $[\![policy_{m}]\!]^{negative, e, a}$

\end{lstlisting}

\subsubsection{AndPolicySet Translation}
$AndPolicySet$ translates to conjunctions of the corresponding policy set translations. 

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Policy Set Translation {$\colon$} AndPolicySet},label={lst:transpolicyformulaAndPolicySet}]
$[\![ and [policySet_{1}, ..., policySet_{m}]]\!]^{e, prin_{u}, a}$ $\triangleq$ $[\![policySet_{1}]\!]^{e, prin_{u}, a}$ $\land$ $...$ $\land$ $[\![policySet_{m}]\!]^{e, prin_{u}, a}$

\end{lstlisting}

\subsection{Principal Translation}
Translation for a \emph{prin} ($[\![ prin ]\!]_{x}$) is a formula that is true if and only if the subject $x$ is in the prin set. A $prin$ is either a single subject or a list of subjects ($\{ subject_{1}, ..., subject_{m} \}$ so the translation covers both cases. 


If the $prin$ is a single subject, the translation is a formula that is true if and only if the subject $x$ is the same as the single subject $subject$.

\subsubsection{Single Subject Translation}
\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Prin Translation {$\colon$} Single subject},label={lst:transprinSingle}]
$[\![ subject ]\!]_{x}$ $\triangleq$ $x=subject$
\end{lstlisting}

\subsubsection{List of Subjects Translation}
Translation of a list of subjects is the disjunction of the translations for each subject.

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Prin Translation {$\colon$} List of subjects},label={lst:transprinListOfSubjects}]

$[\![ \{ subject_{1}, ..., subject_{m} \} ]\!]_{x}$ $\triangleq$ $[\![subject_{1}]\!]_{x}$ $\lor$ $...$ $\lor$ $[\![subject_{m}]\!]_{x}$

\end{lstlisting}




\subsection{Prerequisite Translation}

Translation for a prerequisite is a formula $[\![prerequisite]\!]^{[id_{1}, ..., id_{m}], prin, a}_{x}$, where the set of $id$s refer to identifiers for policies that are implied by the prerequisites, $prin$ is the agreement's user(s) (and to which the prerequisites apply), $a$ is the asset and $x$ is a variable of type $subject$. The translation for a $prerequisite$ is described by translation formulas for each type of $prerequisite$. A $prerequisite$ is either always $true$, a $Constraint$, a $ForEachMember$, a $NotCons$, a $AndPrqs$, a $OrPrqs$ or a $XorPrqs$.

\subsubsection{True Prerequisite Translation}
The translation for a $TruePrq$ yields a formula that is always \emph{true}.

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Prerequisite Translation {$\colon$} Always True Prerequisite},label={lst:transpreRequisiteTruePrq}]
	$[\![ prerequisite::true ]\!]$ $\triangleq$ True
\end{lstlisting}

\subsubsection{Constraint Prerequisite Translation}
The translation for a $Constraint$ is handled by a specialized constraint translation function (coverage of which starts at ~\ref{lst:transconstraintPrin}.

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Prerequisite Translation {$\colon$} Constraint},label={lst:transpreRequisiteConstraint}]

$[\![ prerequisite::constraint ]\!]^{[id_{1}, ..., id_{m}], prin_{u}}_{x}$ $\triangleq$ $[\![ constraint ]\!]^{[id_{1}, ..., id_{m}], prin_{u}}_{x}$ 
\end{lstlisting}

\subsubsection{ForEachMember Prerequisite Translation}
The translation for a $ForEachMember$ is also is handled by a specialized translation function (covered at ~\ref{lst:transforEachMember}.

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Prerequisite Translation {$\colon$} ForEachMember},label={lst:transpreRequisiteForEachMember}]

$[\![ prerequisite::forEachMember ]\!]^{[subject_{1}, ..., subject_{k}], [constraint_{1}, ..., constraint_{m}], [id_{1}, ..., id_{n}]}_{x}$ $\triangleq$ $[\![ forEachMember ]\!]^{[subject_{1}, ..., subject_{k}], [constraint_{1}, ..., constraint_{m}], [id_{1}, ..., id_{n}]}_{x}$ 	
\end{lstlisting}

\subsubsection{NotCons Prerequisite Translation}
The translation for a $NotCons$ yields a formula that is simply the negation of the translation for a constraint.

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Prerequisite Translation {$\colon$} Not Constraint},label={lst:transpreRequisiteNotConstraint}]

$[\![ not$ $prerequisite::constraint ]\!]^{[id_{1}, ..., id_{m}], prin_{u}}_{x}$ $\triangleq$ $\lnot[\![ constraint ]\!]^{[id_{1}, ..., id_{m}], prin_{u}}_{x}$ 
\end{lstlisting}

\subsubsection{AndPrqs Prerequisite Translation}
The translation for a $AndPrqs$ yields a formula that is the conjunction of the translation for each $preRequisite$.

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Prerequisite Translation {$\colon$} Conjunction },label={lst:transpreRequisiteAndPrqs}]

$[\![and$ $[preRequisite_{1}, ..., preRequisite_{k}]]\!]^{[id_{1}, ..., id_{m}], prin_{u}}$ $\triangleq$ $[\![preRequisite_{1}]\!]^{[id_{1}, ..., id_{m}], prin_{u}}$ $\land$ $...$ $\land$ $[\![preRequisite_{k}]\!]^{[id_{1}, ..., id_{m}], prin_{u}}$

\end{lstlisting}

\subsubsection{OrPrqs Prerequisite Translation}
The translation for a $OrPrqs$ yields a formula that is the inclusive disjunction of the translation for each $preRequisite$.

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Prerequisite Translation {$\colon$} Inclusive Disjunction},label={lst:transpreRequisiteOrPrqs}]

$[\![or$ $[preRequisite_{1}, ..., preRequisite_{k}]]\!]^{[id_{1}, ..., id_{m}], prin_{u}}$ $\triangleq$ $[\![preRequisite_{1}]\!]^{[id_{1}, ..., id_{m}], prin_{u}}$ $\lor$ $...$ $\lor$ $[\![preRequisite_{k}]\!]^{[id_{1}, ..., id_{m}], prin_{u}}$

\end{lstlisting}

\subsubsection{XorPrqs Prerequisite Translation}
The translation for a $XorPrqs$ yields a formula that is the exclusive disjunction of the translation for each $preRequisite$.


\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Prerequisite Translation {$\colon$} Exclusive Disjunction},label={lst:transpreRequisiteXorPrqs}]

$[\![Xor$ $[preRequisite_{1}, ..., preRequisite_{k}]]\!]^{[id_{1}, ..., id_{m}], prin_{u}}$ $\triangleq$ $[\![preRequisite_{1}]\!]^{[id_{1}, ..., id_{m}], prin_{u}}$ $\oplus $ $...$ $\oplus$ $[\![preRequisite_{k}]\!]^{[id_{1}, ..., id_{m}], prin_{u}}$

\end{lstlisting}


\subsection{Constraint Translation}

Translation for a constraint is a formula $[\![constraint]\!]^{[id_{1}, ..., id_{m}], prin_{u}, a}_{x}$, where the set of $id$s refer to identifiers for policies that are implied by the constraint, $prin_{u}$ is the agreement's user(s) (and to which the constraint applies), $a$ is the asset and $x$ is a variable of type $subject$. The translation for a $constraint$ is described by translation formulas for each type of $constraint$. A $constraint$ is either a $Principal$, a $Count$, or a $CountByPrin$.

\subsubsection{Principal Constraint Translation}
The translation for a $Principal$ is handled by a specialized translation function (covered at ~\ref{lst:transprin}.   

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Constraint Translation {$\colon$} Principal},label={lst:transconstraintPrin}]

$[\![ constraint::prin ]\!]^{[subject_{1}, ..., subject_{m}]}_{x}$ $\triangleq$ $[\![ prin ]\!]^{[subject_{1}, ..., subject_{m}]}_{x}$ 
\end{lstlisting}

\subsubsection{Count Constraint Translation}
The translation for a $Count$ is handled by a specialized translation function (covered at ~\ref{lst:transcount}.

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Constraint Translation {$\colon$} Count},label={lst:transconstraintCount}]

$[\![ constraint::count [N] ]\!]^{[id_{1}, ..., id_{m}], prin_{u}}_{x}$ $\triangleq$ $[\![ count [N] ]\!]^{[id_{1}, ..., id_{m}], prin_{u}}_{x}$ 
\end{lstlisting}

\subsubsection{CountByPrin Constraint Translation}
The translation for a $CountByPrin$ is handled by the same specialized translation function as that for $Count$. The difference is that $CountByPrin$ overrides the subjects in $prin_{u}$ by a different set of subjects (covered at ~\ref{lst:transcount}.

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Constraint Translation {$\colon$} Count by Principal},label={lst:transconstraintCountbyPrin}]

$[\![ constraint::prin(count [N]) ]\!]^{[subject_{1}, ..., subject_{m}], [id_{1}, ..., id_{n}]}_{x}$ $\triangleq$ $[\![ prin(count [N]) ]\!]^{[subject_{1}, ..., subject_{m}], [id_{1}, ..., id_{n}]}_{x}$ 
\end{lstlisting}


\subsection{forEachMember Translation}

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={ForEachMember Translation {$\colon$} Count by Principal},label={lst:transforEachMember}]

$[\![ forEachMember ]\!]^{[subject_{1}, ..., subject_{k}], [constraint_{1}, ..., constraint_{m}], [id_{1}, ..., id_{n}]}_{x}$ $\triangleq$ $[\![constraint]\!]^{(subject_{1}, constraint_{1}), [id_{1}, ..., id_{n}]}_{x}$ $\land$ $...$ $\land$ $[\![constraint]\!]^{(subject_{1}, constraint_{m}), [id_{1}, ..., id_{n}]}_{x}$ $\land$ $...$ $\land$ $[\![constraint]\!]^{(subject_{2}, constraint_{1}), [id_{1}, ..., id_{n}]}_{x}$ $\land$ $...$ $\land$ $[\![constraint]\!]^{(subject_{2}, constraint_{m}), [id_{1}, ..., id_{n}]}_{x}$ $\land$ $...$ $\land$ $[\![constraint]\!]^{(subject_{k}, constraint_{1}), [id_{1}, ..., id_{n}]}_{x}$ $\land$ $...$ $\land$ $[\![constraint]\!]^{(subject_{k}, constraint_{m}), [id_{1}, ..., id_{n}]}_{x}$ 

\end{lstlisting}

\subsection{''Not Constraint" Translation}

The translation for ``Not Constraint'' was listed in listing ~\ref{lst:transpreRequisiteNotConstraint} earlier but we repeat it here to go along the Coq version. 

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Not Constraint Translation},label={lst:transnotCons}]

$[\![ not$ $constraint ]\!]^{[id_{1}, ..., id_{m}], prin_{u}}_{x}$ $\triangleq$ $\lnot[\![ constraint ]\!]^{[id_{1}, ..., id_{m}], prin_{u}}_{x}$ 

\end{lstlisting}

\subsection{Count Translation}
\subsubsection{Count Translation For Subject/ID Pair}
The translation for $Count$ or $CountByPrin$ for a pair of subject and policy identifier is a formula that is true if the number of times the $subject_{1}$ has invoked a policy with policy identifier $id_{1}$ is smaller than $N$.

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Count Translation {$\colon$} subject and policyId pair},label={lst:transcountSinglePair}]

$[\![ count [N] ]\!]^{subject_{1}, id_{1}}_{x}$ $\triangleq$ $getCount(subject_{1}, id_{1}) < N$
\end{lstlisting}

\subsubsection{Count Translation For Subject/ID Pairs}
The translation for $Count$ or $CountByPrin$ for subject and policy identifier pairs is a formula that is true if the total number of times that a subject has invoked a policy with policy identifier $id_{i}$ is smaller than $N$.

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Count Translation {$\colon$} subject and policyId pairs},label={lst:transcountPairs}]

$[\![ count [N] ]\!]^{[id_{1}, ..., id_{m}], prn}_{x}$ $\triangleq$ 

$(getCount(getSubject(prn)_{1}, id_{1})$ $+ ... +$ $getCount(getSubject(prn)_{1}, id_{m})$ $+ ... +$ $getCount(getSubject(prn)_{k}, id_{1})$ $+ ... +$ $getCount(getSubject(prn)_{k}, id_{m}))$ < $N$


\end{lstlisting}






\section{Semantics in Coq}
\label{sec:Semanticsincoq}

% COQ
The translation functions plus the auxiliary types and infrastructure, implementing the semantics have been encoded in Coq. Translation functions all return the \emph{sort} $Prop$. 

Talk about Props here...


Whether a permission is granted or denied depends on the agreements in question but also on the facts recorded in the environment. For ODRL0 those facts revolve around the number of times a policy has been used to justify an action (see \ref{subsec:odrl0} for more details on odrl0). We encode this information in an \emph{environment} which is a conjunction of equalities of the form \emph{count(s, policyId) = n}. 

% COQ
The Coq version of the count equality is a new inductive type called \emph{count_equality}. An environment is defined to be a non-empty list of count_equality objects.

\lstset{language=Coq, frame=single, caption={Environments and Counts},label={lst:environmentcoq}}
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
Inductive count_equality : Set := 
   | CountEquality : subject -> policyId -> nat -> count_equality.

Inductive environment : Set := 
  | SingleEnv : count_equality -> environment
  | ConsEnv :  count_equality ->  environment -> environment.

\end{lstlisting}
\end{minipage}

The non-empty list data structure is defined as a new \emph{polymorphic} inductive type in its own section. The non-empty list definition is listed at listing ~\ref{lst:nonemptylistcoq}.

\lstset{language=Coq, frame=single, caption={nonemptylist type},label={lst:nonemptylistcoq}}
\begin{lstlisting}

Section nonemptylist.

Variable X : Set.

Inductive nonemptylist : Set :=
  | Single : X -> nonemptylist 
  | NewList : X -> nonemptylist -> nonemptylist.

End nonemptylist.
\end{lstlisting}

Translation of the top level $agreement$ element proceeds by case analysis on the structure of the agreement. However an agreement can only be built one way; by calling the constructor $Agreement$. The translation proceeds by calling the translation function for the corresponding $policySet$ namely the parameter to $Agreement$ called $ps$.


\lstset{language=Coq, frame=single, caption={Translation of agreement},label={lst:transagreement}}
\begin{lstlisting}

Definition trans_agreement (e:environment)(ag:agreement) : Prop :=
  match ag with 
    | Agreement prin_u a ps => trans_ps e ps prin_u a
  end.

\end{lstlisting}

Translation of a $policySet$ (called $trans\_ps$ in listing ~\ref{lst:transpsCoq}), takes as input $e$, the environment, $ps$, the policy set, $prin_{u}$, the agreement's user, and $a$, the asset, and proceeds by case analysis of different policySet constructors and recursing into translation functions for the composing elements. A policySet is either a $PrimitivePolicySet$, $PrimitiveExclusivePolicySet$ or a $AndPolicySet$. 

Note that to implement the translation for an $AndPolicySet$ a local function $trans_ps_list$ has been defined where for a single $policySet$, $trans_ps$ is called, and for a list of $policySet$s, the conjunction of $trans_ps$s are returned.

\lstset{language=Coq, frame=single, caption={Translation of Policy Set},label={lst:transpsCoq}}
\begin{minipage}{\linewidth}
\begin{lstlisting}

Fixpoint trans_ps
  (e:environment)(ps:policySet)(prin_u:prin)(a:asset){struct ps} : Prop :=

let trans_ps_list := (fix trans_ps_list (ps_list:nonemptylist policySet)(prin_u:prin)(a:asset){struct ps_list}:=
  match ps_list with
    | Single ps1 => trans_ps e ps1 prin_u a
    | NewList ps ps_list' => ((trans_ps e ps prin_u a) /\ (trans_ps_list ps_list' prin_u a))
  end) in
    match ps with
    | PrimitivePolicySet prq p => forall x, (((trans_prin x prin_u) /\ 
                                   (trans_preRequisite e x prq (getId p) prin_u)) -> 
                                   (trans_policy_positive e x p prin_u a))  

    | PrimitiveExclusivePolicySet prq p => forall x, ((((trans_prin x prin_u) /\ 
                                              (trans_preRequisite e x prq (getId p) prin_u)) -> 
                                             (trans_policy_positive e x p prin_u a)) /\
                                            ((not (trans_prin x prin_u)) -> (trans_policy_negative e x p a)))
                   
    | AndPolicySet ps_list => trans_ps_list ps_list prin_u a
    end.
\end{lstlisting}
\end{minipage}



% COQ
Translation of a \emph{prin} (called $trans\_prin$ in listing ~\ref{lst:transprin}) takes as input $x$, the $subject$ in question, $p$, the principal or the $prin$,  and proceeds based on whether $p$ is a single subject or a list of subjects. If $p$ is a single subject, $s$, the $Prop$ $x=s$ is returned. Otherwise the disjunction of the translation of the first subject in $p$ ($s$) and the $rest$ of the subjects is returned.

\lstset{language=Coq, frame=single, caption={Translation of a Prin},label={lst:transprin}}
\begin{lstlisting}

Fixpoint trans_prin
  (x:subject)(p: prin): Prop :=

  match p with
    | Single s => (x=s)
    | NewList s rest => ((x=s) \/ trans_prin x rest)
  end.
\end{lstlisting}


A positive translation for a policy (called $trans\_policy\_positive$ in listing ~\ref{lst:transpolicypositiveCoq}) takes as input $e$, the $environment$, $x$, the $subject$, $p$, the $policy$ to translate, $prin_{u}$, the agreement's user, and $a$, the asset and proceeds based on whether we have a $PrimitivePolicy$ or a $AndPolicy$. If the policy is a $PrimitivePolicy$ an implication is returned which indicates $x$ is \emph{permitted} to do $action$ to $a$, if the $preRequisite$ holds. 

$Permitted$ is a predicate specified as $Parameter Permitted : subject -> act -> asset -> Prop.$ So $Permitted$ predicate takes a $subject$, an $act$ (an action) and an $asset$ and returns a $Prop$. 

Note that to implement the translation for an $AndPolicy$ a local function $trans\_p\_list$ has been defined where for a single $policy$, $trans\_policy\_positive$ is returned, and for a list of $policy$s, the conjunction of $trans\_policy\_positive$s are returned.

\lstset{language=Coq, frame=single, caption={Translation of a positive policy},label={lst:transpolicypositiveCoq}}
\begin{lstlisting}

Fixpoint trans_policy_positive
  (e:environment)(x:subject)(p:policy)(prin_u:prin)(a:asset){struct p} : Prop :=

let trans_p_list := (fix trans_p_list (p_list:nonemptylist policy)(prin_u:prin)(a:asset){struct p_list}:=
                  match p_list with
                    | Single p1 => trans_policy_positive e x p1 prin_u a
                    | NewList p p_list' => 
                        ((trans_policy_positive e x p prin_u a) /\ 
                         (trans_p_list p_list' prin_u a))
                  end) in


  match p with
    | PrimitivePolicy prq policyId action => ((trans_preRequisite e x prq (Single policyId) prin_u) ->
                                              (Permitted x action a))
    | AndPolicy p_list => trans_p_list p_list prin_u a
  end.
\end{lstlisting}

A negative translation for a policy (called $trans\_policy\_negative$ in listing ~\ref{lst:transpolicynegativeCoq}) takes as input $e$, the $environment$, $x$, the $subject$, $p$, the $policy$ to translate, and $a$ the asset and proceeds based on whether we have a $PrimitivePolicy$ or a $AndPolicy$. If the policy is a $PrimitivePolicy$ an implication is returned which indicates $x$ is forbidden to do $action$ to $a$ regardless of whether $preRequisite$ holds. Note that the notation $(\lnot)$ indicates that $Permitted$ may be negated. As the case for the positive translation, to implement the translation for an $AndPolicy$ a local function $trans\_p\_list$ has been defined where for a single $policy$, $trans\_policy\_negative$ is returned, and for a list of $policy$s, the conjunction of $trans\_policy\_negative$s are returned.


\lstset{language=Coq, frame=single, caption={Translation of a negative policy},label={lst:transpolicynegativeCoq}}
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}

Fixpoint trans_policy_negative
  (e:environment)(x:subject)(p:policy)(a:asset){struct p} : Prop :=
let trans_p_list := (fix trans_p_list (p_list:nonemptylist policy)(a:asset){struct p_list}:=
                  match p_list with
                    | Single p1 => trans_policy_negative e x p1 a
                    | NewList p p_list' => ((trans_policy_negative e x p a) /\ 
                                            (trans_p_list p_list' a))
                  end) in


  match p with
    | PrimitivePolicy prq policyId action => not (Permitted x action a)
    | AndPolicy p_list => trans_p_list p_list a
  end.
\end{lstlisting}
\end{minipage}

The translation of a $prerequisite$ (called $trans\_preRequisite$ in listing ~\ref{lst:transpreRequisiteCoq}) takes as input $e$, the $environment$, $x$, the $subject$, $prq$, the $preRequisite$ to translate, $IDs$, the set of identifiers (of policies implied by the $prq$), $prin_{u}$, the agreement's user, and proceeds by case analysis on the structure of the $prerequisite$. A $prerequisite$ is either a $TruePrq$, a $Constraint$, a $ForEachMember$, a $NotCons$, a $AndPrqs$, a $OrPrqs$ or a $XorPrqs$. 

In listing ~\ref{lst:transpreRequisiteCoq} the translation for $TruePrq$ is the Prop $True$, the translations for $Constraint$, $ForEachMember$ and $NotCons$ simply call respective translation functions for corresponding types $constraint$ and $forEachMember$ (namely $trans\_constraint$, $trans\_forEachMember$ and $trans\_notCons$). Note that the translation for $AndPrqs$, $OrPrqs$ and $XorPrqs$ have not yet been implemented but based on the their many-sorted-logic formulas' specifications (~\ref{lst:preRequisiteast}) they will be conjunctions, disjunctions and exclusive disjunctions of translations for each $prerequisite$.

\lstset{language=Coq, frame=single, caption={Translation of a PreRequisite},label={lst:transpreRequisiteCoq}}
\begin{lstlisting}

Definition trans_preRequisite
  (e:environment)(x:subject)(prq:preRequisite)(IDs:nonemptylist policyId)(prin_u:prin) : Prop := 

  match prq with
    | TruePrq => True
    | Constraint const => trans_constraint e x const IDs prin_u 
    | ForEachMember prn const_list => trans_forEachMember e x prn const_list IDs 
    | NotCons const => trans_notCons e x const IDs prin_u 
    | AndPrqs prqs => True 
    | OrPrqs prqs => True 
    | XorPrqs prqs => True 
  end.
\end{lstlisting}

The translation of a $constraint$ (called $trans\_constraint$ in listing ~\ref{lst:transconstraintCoq}) takes as input $e$ the $environment$, $x$ the $subject$, $const$, the $constraint$ to translate, $IDs$, the set of identifiers (of policies implied by the parent $preRequisite$) and $prin_{u}$, the agreement's user and proceeds by case analysis on the structure of the $constraint$. A $constraint$ is either a $Principal$, a $Count$ or a $CountByPrin$.

In listing ~\ref{lst:transconstraintCoq} the translation for $Principal$ returns the translation function (namely $trans\_prin$) for the $prn$ (the $prin$ that accompanies the $const$ constraint). The translation for $Count$ and $CountByPrin$ return the translation function $trans\_count$. For $Count$ the $prin$ used is the agreement's user, whereas the $prin$ used is the one passed to $CountByPrin$ namely $prn$.


\lstset{language=Coq, frame=single, caption={Translation of a Constraint},label={lst:transconstraintCoq}}
\begin{lstlisting}

Fixpoint trans_constraint 
  (e:environment)(x:subject)(const:constraint)(IDs:nonemptylist policyId)
  (prin_u:prin){struct const} : Prop := 
  match const with
    | Principal prn => trans_prin x prn
  
    | Count n => trans_count e n IDs prin_u 

    | CountByPrin prn n => trans_count e n IDs prn 

  end.
  
\end{lstlisting}

The translation of a $forEachMember$ (called $trans\_forEachMember$ in listing ~\ref{lst:transforEachMemberCoq}) takes as input $e$ the $environment$, $x$ the $subject$, $principals$, the set of subjects that override the agreement's user(s), $const\_list$ the set of constraints and $IDs$, the set of identifiers (of policies implied by the parent $preRequisite$).

To implement the translation for a $forEachMember$ we start by calling an auxiliary function $process\_two\_lists$ that effectively returns a new list composed of pairs of members of the first list and the second list (the cross-product of the two input lists). In the case of a $forEachMember$ translation, the call is ``$process\_two\_lists$ $principals$ $const\_list$'' which returns a list of pairs of subject and constraint namely $prins\_and\_constraints$. $prins\_and\_constraints$ is then passed to a locally defined function \emph{ trans_forEachMember_Aux} where for a single pair of subject and constraint $trans\_constraint$ is called and for a list of pairs of subject and constraints, the conjunction of $trans\_constraint$s (for the first pair) and $trans\_forEachMember\_Aux$s (for the rest of the pairs) are returned.



\lstset{language=Coq, frame=single, caption={Translation of forEachMember},label={lst:transforEachMemberCoq}}
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}

Fixpoint trans_forEachMember
         (e:environment)(x:subject)(principals: nonemptylist subject)(const_list:nonemptylist constraint)
         (IDs:nonemptylist policyId){struct const_list} : Prop := 

let trans_forEachMember_Aux   
  := (fix trans_forEachMember_Aux
         (prins_and_constraints : nonemptylist (Twos subject constraint))
         (IDs:nonemptylist policyId){struct prins_and_constraints} : Prop :=

      match prins_and_constraints with
        | Single pair1 => trans_constraint e x (right pair1) IDs (Single (left pair1)) 
        | NewList pair1 rest_pairs =>
            (trans_constraint e x (right pair1) IDs (Single (left pair1))) /\
            (trans_forEachMember_Aux rest_pairs IDs)
      end) in

      let prins_and_constraints := process_two_lists principals const_list in
      trans_forEachMember_Aux prins_and_constraints IDs.

\end{lstlisting}
\end{minipage}

The translation of a $NotCons$ (called $trans\_notCons$ in listing ~\ref{lst:transnotConsCoq}) takes as input $e$ the $environment$, $x$ the $subject$, $const$, the $constraint$ to translate, $IDs$, the set of identifiers (of policies implied by the parent $preRequisite$) and $prin_{u}$, the agreement's user and proceeds to return the negation of $trans\_constraint$ (see listing ~\ref{lst:transconstraintCoq}).


\lstset{language=Coq, frame=single, caption={Translation of not cons},label={lst:transnotConsCoq}}
\begin{lstlisting}

Definition trans_notCons
  (e:environment)(x:subject)(const:constraint)(IDs:nonemptylist policyId)(prin_u:prin) : Prop :=
  ~ (trans_constraint e x const IDs prin_u).
\end{lstlisting}




The translation of a $Count$ or a $CountByPrin$ (called $trans\_count$ in listing ~\ref{lst:transcountCoq}) takes as input $e$ the $environment$, $n$ the total number of times the subjects mentioned in $prin_{u}$ (last parameter) may invoke the policies identified by $IDs$ (third parameter).

To implement the translation for a $Count$ or a $CountByPrin$ we start by calling an auxiliary function $process\_two\_lists$ that effectively returns a new list composed of pairs of members of the first list and the second list (the cross-product of the two input lists). In the case of $trans\_count$, the call is ``$process\_two\_lists$ $IDs$ $prin_u$'' which returns a list of pairs of $policyId$ and $subject$ namely $ids\_and\_subjects$. $ids\_and\_subjects$ is then passed to a locally defined function \emph{trans_count_aux}.

$trans\_count\_aux$ returns the current count for a single pair of $policyId$ and $subject$ (the call to $getCount$ which looks up the environment $e$ and returns the current count per each $subject$ and $policyId$) and for a list of pairs of $policyId$ and $subject$s, the addition of $get\_count$ (for the first pair) and $trans\_count\_aux$s (for the rest of the pairs) is returned. 

A local variable $running_total$ has the value returned by $trans\_count\_aux$. Finally the proposition $running_total < n$ is returned as the translation for a $Count$ or a $CountByPrin$.

Note that the only difference between translations for a $Count$ and a $CountByPrin$ is the additional $prn$ parameter for $CountByPrin$ which allows for getting counts for subjects not necessarily the same as $prin_{u}$, the agreement's user(s).

\lstset{language=Coq, frame=single, caption={Translation of count},label={lst:transcountCoq}}
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
Fixpoint trans_count 
  (e:environment)(n:nat)(IDs:nonemptylist policyId)
  (prin_u:prin) : Prop := 

  let trans_count_aux 
    := (fix trans_count_aux
         (ids_and_subjects : nonemptylist (Twos policyId subject)) : nat :=
     match ids_and_subjects with
        | Single pair1 => getCount e (right pair1) (left pair1)
        | NewList pair1 rest_pairs =>
            (getCount e (right pair1)(left pair1)) +
            (trans_count_aux rest_pairs)
      end) in
  
  let ids_and_subjects := process_two_lists IDs prin_u in
  let running_total := trans_count_aux ids_and_subjects in
  running_total < n.
\end{lstlisting}
\end{minipage}
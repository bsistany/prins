%======================================================================
\chapter{Introduction}
%======================================================================
Digital rights management, \emph{DRM}, refers to the digital management of rights associated with the access or usage of digital assets. There are various aspects of rights management however. According to the authors of the whitepaper ``A digital rights management ecosystem model for the education community,'' digital rights management systems cover the following four areas: 1) defining rights 2) distributing/acquiring rights 3) enforcing rights and 4) tracking usage \cite{collier}. 

Rights Expression Languages, \emph{RELs}, or more precisely when dealing with digital assets, Digital Rights Expression Languages \emph{DRELs} deal with the ``rights definition'' aspect of the DRM ecosystem. A DREL, allows the expression and definition of digital asset usage rights such that other areas of the DRM ecosystem namely the enforcement mechanism and the usage tracking components can function correctly.

Currently the most popular RELs are the eXtensible rights Markup Language, \emph{XrML} [bib], and the Open Digital Rights Language, \emph{ODRL} [bib]. Both of these languages are XML based and are considered declarative languages. XrML has been selected to be the REL for \emph{MPEG-21} which is an ISO standard for multimedia applications. ODRL is also a standards based REL which has been accepted as part of the W3C community with the mandate of standardizing how rights and policies, related to the usage of digital content on the Open Web Platform, \emph{OWP}, are expressed [wikipedia]. ODRL 2.0 supports expression of rights and also privacy rules for social media while ODRL 1.0 was only dealing with the mobile ecosystem -- ODRL 1.0 was adopted by the Open Mobile Alliance, \emph{OMA} in 2000.

As popular as both XrML and ODRL are, their adoption and usage is still somewhat limited in practice. Both Apple and Microsoft for example have defined their own lightweight RELs [problem with RELs paper] in \emph{Fair Play} (Apple) and in \emph{PlayReady} (Microsoft). The authors of [the problem with RELs] argue that both these RELs and other ones are simply too complex to be used effectively since they try to cover much of the DRM ecosystem. 

Another issue with the current batch of RELs are due to their semantics being expressed in a natural language (e.g. English). By necessity natural languages are ambiguous and open to interpretation. 

To formalize the semantics of RELS several approaches have been attempted by various authors. The main categories are logic based, operational semantics based interpreters and finally web ontology based (from the Knowledge Representation Field). In this thesis we will focus on the logic based approach to formalizing semantics and will study a specific logic based language that is a translation from a subset of ODRL.









%----------------------------------------------------------------------
\section{Logic Based Semantics for ODRL}
%----------------------------------------------------------------------

%See equation \ref{eqn_pi} on page \pageref{eqn_pi}.\footnote{A famous %equation.}

Formal logic can represent the statements and facts we express in a natural language like English. Propositional logic is expressive enough to express simple facts as propositions and allows uses connectives to allow for the negation, conjunction and disjunction of the facts. However propositional logic is not expressive enough to express policies of the kind used in languages like ODRL and XrML. For example, a simple policy expressed in English like ``All who pay 5 dollars can watch the movie Toy Story'' cannot be expressed in propositional logic because the concept of  variables doesn't exist. 

The higher order logic called ``Predicate Logic'' or ``First Order Logic'' \emph{FOL} is more suitable and has the expressive power to represent policies written in English. Moreover, FOL can be used to capture the meaning of policies in an unambiguous way.

Halpern and Weissman [Using First Order Logic to Reason about Policies] propose a fragment of FOL to represent and reason about policies. The fragment of FOL they arrive at is called \emph{Lithium} which is decidable and allows for efficiently answering interesting queries. Lithium restricts policies to be written based on the concept of ``bipolarity'' which disallows by construction policies that both permit and deny an action on an object.

\section{Pucella 2006}
Pucella and Weissman \cite{pucella2006} specify a predicate logic based based language that represents a subset of ODRL.

\section{what will I do?}


\subsection{Coq}


	• Program correctness
	• Formal verification of software
	• Certified programs
	• Proof assistant
	• Interactive and mechanized theorem proving
	• Examples of machine assisted proofs: CompCert, four-color theorem proof
	• Coq is based on a higher-order functional programming language
	• Dependent Types
		○ Subset types
		○ Easier than writing explicit proofs
	• Write formal specification and proofs that programs comply to their specification (a-short-intro-to-coq)
	• Automatically extract code from specifications as Ocaml or Haskell (a-short-intro)
	• Properties, programs and proofs are all formalized in the same language called CIC (Calculus of inductive Constructions). (a-short-intro)
	• Coq uses a sort called Prop for propositions
	• Coq art:
	• Well-formed propositions are assertions  one can express about values such as mathematical objects or even programs e.g. 3 < 8
		○ Note that assertions may be true, false or simply conjectures
		○ An assertion is only true in general if a proof is provided
		○ However hand written proofs are difficult to verify
		○ Coq provides an environment for developing proofs including a formal language to express proofs in, the language itself being built using proof theory making it possible to step by step verification of the proofs
		○ Mechanized proof verification requires a "proof" that the verification algorithm is correct itself in applying all the formal rules correctly







\section{Abstract Syntax}

[Pucella2006] uses abstract syntax instead of XML to express statements in the ODRL language. The abstract syntax used is a more compact representation than XML based language ODRL policies are written in and furthermore it simplifies specifying the semantics as we shall see. As an example here is an agreement written in ODRL and the comparable agreement expressed in the abstract syntax [Pucella2006].

\lstset{language=XML}
\begin{lstlisting}[caption={The Agreement in XML},label={lst:agreementxml}]
<agreement>
 <asset> <context> <uid> Treasure Island </uid> </context> </asset>
 <permission>
   <display>
    <constraint>
     <cpu> <context> <uid> Mary's computer </uid> </context> </cpu>
    </constraint>
   </display>
   <print>
    <constraint> <count> 2 </count> </constraint>
   </print>
  <requirement>
   <prepay>
    <payment> <amount currency="AUD"> 5.00</amount> </payment>
   </prepay>
  </requirement>
 </permission>
 <party> <context> <name> Mary Smith </name> </context> </party>
</agreement>
\end{lstlisting}
The agreement is shown using the syntax from [Pucella2006] below.

\lstset{language=Pucella2006}
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}[frame=single, caption={The Agreement As Pucella2006},label={lst:agreementpucella2006}]
agreement
 for Mary Smith 
 about Treasure Island 
 with prePay[5.00] -> and[cpu[Mary's Computer] => display,
                                      count[2] => print].
\end{lstlisting}
\end{minipage} 

% \emph{prin\textsubscript{u}}
In the following we will cover the \emph{abstract syntax} of a subset of ODRL expressed as Coq's \emph{Inductive Types} and Definitions. We will call this subset \emph{ODRL0} both because it is a variation of Pucella's ODRL language and also because it is missing some ODRL constructs such as \emph{Requirements} and \emph{Conditions} - we will add the missing pieces making up what we will call \emph{ODRL1} and perhaps \emph{ODRL2} (the latter only if needed). We will also describe ODRL0 in a \emph{BNF} grammar that looks more like Pucella's ODRL grammar. BNF style grammars are less formal as they give some suggestions about the surface syntax of expressions [Pierce1] without getting into lexical analysis and parsing related aspects such as precedence order of operators. The Coq version in contrast is more formal and could be directly used for building compilers and interpreters. We will present both the BNF version and the Coq version for each construct of ODRL0 [Pierce1]. To get started let's see what the listing~\ref{lst:agreement} would look like in ODRL0's Coq version.

\lstset{language=Coq}
\begin{lstlisting}[frame=single, caption={Coq version of agreement for Mary Smith},label={lst:agreementcoq}]

Agreement (Single MarySmith) Treasure Island 
 (PrimitivePolicySet (Constraint (PrePay 5.00))
  (AndPolicy 
   (NewList (PrimitivePolicy (Constraint 
                              (Principal 
                               (Single MarysComputer))) id1 Display)
   (Single (PrimitivePolicy (Constraint (Count 2)) id2 Print))))).
\end{lstlisting}


%\coqdoceol
%\coqdocvar{Agreement} (\coqdocvar{Single} \coqdocvar{Mary Smith}) \coqdocvar{Treasure Island} (\coqdocvar{PrimitivePolicySet} (\coqdocvar{Constraint} (\coqdocvar{PrePay} 5.00))\coqdoceol
%\coqdocindent{0.50em}
%(\coqdocvar{AndPolicy} (\coqdocvar{NewList} (\coqdocvar{PrimitivePolicy} (\coqdocvar{Constraint} (\coqdocvar{Principal} (\coqdocvar{Single} \coqdocvar{Mary's Computer}))) \coqdocvar{id1} \coqdocvar{Display})\coqdoceol
%\coqdocindent{6.00em}
%(\coqdocvar{Single} (\coqdocvar{PrimitivePolicy} (\coqdocvar{Constraint} (\coqdocvar{Count} 2)) \coqdocvar{id2} \coqdocvar{Print}))))).\coqdoceol
%\coqdocemptyline
%\coqdocemptyline

The top level ODRL0 production is the \emph{agreement}. An agreement expresses what actions a subject may perform on an object. Syntactically an agreement is composed of a set of subjects/users called a \emph{principal} (\emph{prin}), an \emph{asset} and a \emph{Policy Set} (\emph{PolicySet}).

% agreement
\lstset{language=AST}
\begin{lstlisting}[frame=single, caption={agreement},label={lst:agreement}]
<agreement> ::=  <prin> <asset> <policySet> 
\end{lstlisting}



% prin
\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={prin},label={lst:prin}]
<prin> ::=  { <subject$_{1}$>, ..., <subject$_{m}$> }
\end{lstlisting}



% asset
\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={asset},label={lst:asset}]
<asset> ::= 'Number'
\end{lstlisting}


% subject
\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={subject},label={lst:subject}]
<subject> ::= 'Number'
\end{lstlisting}



% policySet

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={policySet},label={lst:policySet}]
<policySet> ::=  
	$\vert$ <PrimitivePolicySet> : <preRequisite><policy> 
	$\vert$ <PrimitiveExclusivePolicySet> : <preRequisite><policy>	 
	$\vert$ <AndPolicySet> : { <policySet$_{1}$>, ..., <policySet$_{m}$> }	
\end{lstlisting}


% policy

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={policy},label={lst:policy}]
<policy> ::=  
	$\vert$ <PrimitivePolicy> : <preRequisite><policyId><act>
	$\vert$ <AndPolicy> : { <policy$_{1}$>, ..., <policy$_{m}$> }	
\end{lstlisting}


% act
\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={act},label={lst:act}]
<act> ::= 'Play' $\vert$ 'Print' $\vert$ 'Display'
\end{lstlisting}


% id
\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={policyId},label={lst:policyId}]
<policyId> ::= 'Number'
\end{lstlisting}


% prq

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={preRequisite},label={lst:preRequisite}]
<preRequisite> ::=  
	$\vert$ <TruePrq> : 'True'
	$\vert$ <Constraint> : <constraint>	 
	$\vert$ <ForEachMember> : <prin>{ <constraint$_{1}$>, ..., <constraint$_{m}$> }	
	$\vert$ <NotCons> : <constraint>
	$\vert$ <AndPrqs> : { <preRequisite$_{1}$>, ..., <preRequisite$_{m}$> }		 
	$\vert$ <OrPrqs> : { <preRequisite$_{1}$>, ..., <preRequisite$_{m}$> }	
	$\vert$ <XorPrqs> : { <preRequisite$_{1}$>, ..., <preRequisite$_{m}$> }		
\end{lstlisting}


% constraint
\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={constraint},label={lst:constraint}]
<constraint> ::=  
	$\vert$ <Principal> : <prin>
	$\vert$ <Count> : 'Number'	 
	$\vert$ <CountByPrin> : <prin> 'Number'
\end{lstlisting}

% ---------------------------------- COQ -----------------------
\section{Coq Version}

\lstset{language=Coq}
\begin{lstlisting}[frame=single, caption={Coq version of agreement},label={lst:agreementcoq}]
Inductive agreement : Set :=
  | Agreement : prin -> asset -> policySet -> agreement.
\end{lstlisting}

% prin 
\lstset{language=Coq}
\begin{lstlisting}[frame=single, caption={prin},label={lst:princoq}]
Definition prin := nonemptylist subject.
\end{lstlisting}

% asset
\lstset{language=Coq}
\begin{lstlisting}[frame=single, caption={asset},label={lst:asset}]
Definition asset := nat.
\end{lstlisting}



% subject
\lstset{language=Coq}
\begin{lstlisting}[frame=single, caption={subject},label={lst:subject}]
Definition subject := nat.
\end{lstlisting}


% policySet
\lstset{language=Coq}
\begin{lstlisting}[frame=single, caption={policySet},label={lst:policySet}]
Inductive policySet : Set :=
  | PrimitivePolicySet : preRequisite -> policy -> policySet 
  | PrimitiveExclusivePolicySet : preRequisite -> policy  -> policySet 
  | AndPolicySet : nonemptylist policySet -> policySet.
\end{lstlisting}

% policy
\lstset{language=Coq}
\begin{lstlisting}[frame=single, caption={policy},label={lst:policy}]
Inductive policy : Set :=
  | PrimitivePolicy : preRequisite -> policyId -> act -> policy 
  | AndPolicy : nonemptylist policy -> policy.
\end{lstlisting}

% act
\lstset{language=Coq}
\begin{lstlisting}[frame=single, caption={act},label={lst:act}]
Definition act := nat.
\end{lstlisting}

% id
\lstset{language=Coq}
\begin{lstlisting}[frame=single, caption={policyId},label={lst:policyId}]
Definition policyId := nat.
\end{lstlisting}

% prq
\lstset{language=Coq}
\begin{lstlisting}[frame=single, caption={preRequisite},label={lst:preRequisite}]
Inductive preRequisite : Set :=
  | TruePrq : preRequisite
  | Constraint : constraint -> preRequisite 
  | ForEachMember : prin  -> nonemptylist constraint -> preRequisite
  | NotCons : constraint -> preRequisite 
  | AndPrqs : nonemptylist preRequisite -> preRequisite
  | OrPrqs : nonemptylist preRequisite -> preRequisite
  | XorPrqs : nonemptylist preRequisite -> preRequisite.
\end{lstlisting}

% constraint
\lstset{language=Coq}
\begin{lstlisting}[frame=single, caption={preRequisite},label={lst:preRequisite}]
Inductive constraint : Set :=
  | Principal : prin  -> constraint 
  | Count : nat -> constraint 
  | CountByPrin : prin -> nat -> constraint.
\end{lstlisting}


%----------------------------------------------------------------------
\section{Semantics}


In this section, we describe the semantics of <Bahman> language by a translation from each language object (e.g. agreement) to a proposition 
%
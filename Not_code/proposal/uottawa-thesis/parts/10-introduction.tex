%======================================================================
\chapter{Introduction}
%======================================================================

\section{Digital Rights} 

\ac{drm} refers to the digital management of rights associated with the access or usage of digital assets. There are various aspects of rights management however. According to the authors of the whitepaper ``A digital rights management ecosystem model for the education community,''(~\cite{collier})
 digital rights management systems cover the following four areas: 1) defining rights 2) distributing/acquiring rights 3) enforcing rights and 4) tracking usage.

\section{Policy Expression Languages}

\ac{rel}s, or more precisely \ac{drel}s when dealing with digital assets deal with the ``rights definition'' aspect of the \ac{drm} ecosystem. A \ac{drel}, allows the expression and definition of digital asset usage rights such that other areas of the \ac{drm} ecosystem, namely the enforcement mechanism and the usage tracking components can function correctly.

Currently the most popular \ac{rel}s are the \ac{xrml}~\cite{Wang}, and the \ac{odrl}~\cite{odrloneone}. Both of these languages are XML based and are considered declarative languages. \ac{xrml} has been selected to be the REL for \emph{MPEG-21} which is an ISO standard for multimedia applications. \ac{odrl} is also a standards based \ac{rel} which has been accepted as part of the W3C community with the mandate of standardizing how rights and policies, related to the usage of digital content on the Open Web Platform, \emph{OWP}~\cite{openwebplatform}, are expressed. \ac{odrl} 2.0 supports expression of rights and also privacy rules for social media while \ac{odrl} 1.0 was only dealing with the mobile ecosystem -- \ac{odrl} 1.0 was adopted by the Open Mobile Alliance, \emph{OMA} in 2000.

As popular as both \ac{xrml} and \ac{odrl} are, their adoption and usage is still somewhat limited in practice. Both Apple and Microsoft for example have defined their own lightweight \ac{rel}s~\cite{problemwithrels} in \emph{Fair Play}~\cite{fairplay} and in \emph{PlayReady}~\cite{playready}. The authors of~\cite{problemwithrels} argue that both these \ac{rel}s (\ac{xrml} and \ac{odrl}) and others are simply too complex to be used effectively (for expressing rights) since they also try to cover much of the the enforcement and tracking aspects of \ac{drm}s.

Rights expressions in \ac{drel}s and specifically \ac{odrl} are used to arbitrate access to assets under conditions. The main construct in \ac{odrl} is the \emph{agreement} which specifies users, asset(s) and policies whereby controls on users' access to the assets are described. This is very similar to how access control conditions are expressed in access control policy languages such as \ac{xacml}~\cite{xacml} and \ac{selinux}~\cite{selinux}. In fact several authors have worked on interoperability between \ac{rel}s and access control policy languages, specifically between \ac{odrl} and \ac{xacml},~\cite{prados2005interoperability}~\cite{maronas2009architecture} and also on translation from from high level policies of \ac{xacml}to low-level and fine grained policies of \ac{selinux}~\cite{alam2008usage}. 

In this thesis we will be generalizing the concept of a policy language from \ac{odrl} to \ac{selinux} by adapting the \ac{odrl} policy language constructs including the developed formal semantics to be used for \ac{selinux}, with the final goal of performing formal verification on both types of policies, in a unified manner.



%----------------------------------------------------------------------
\section{Semantics Of \ac{odrl} Policies}
%----------------------------------------------------------------------


Formal methods help ensure that a system behaves correctly with respect to a specification of its desired behavior~\cite{TAPL}. This specification of the desired behavior is what's referred to as \emph{semantics} of the system. Using formal methods requires defining precise and formal semantics, without which analysis and reasoning about properties of the system in question would become impossible. For example, an issue with the current batch of \ac{rel}s are due to their semantics being expressed in a natural language (e.g. English) which by necessity results in ambiguous and open to interpretation behavior. 

To formalize the semantics of \ac{odrl} several approaches have been attempted by various authors. Most are logic based~\cite{Halpern2008}~\cite{pucella2006} while others are based on finite-automata~\cite{Holzer}, operational semantics based interpreters~\cite{Safavi-naini} and web ontology (from the Knowledge Representation Field)~\cite{Kasten2010MTS}. In this thesis we will focus on the logic based approach to formalizing semantics and will study a specific logic based language that is a translation from a subset of \ac{odrl}.



\section{Logic Based Semantics}

%See equation \ref{eqn_pi} on page \pageref{eqn_pi}.\footnote{A famous %equation.}

Formal logic can represent the statements and facts we express in a natural language like English. Propositional logic is expressive enough to express simple facts as propositions and uses connectives to allow for the negation, conjunction and disjunction of the facts. However propositional logic is not expressive enough to express policies of the kind used in languages like ODRL and XrML. For example, a simple policy expressed in English like ``All who pay 5 dollars can watch the movie Toy Story'' cannot be expressed in propositional logic because the concept of  variables doesn't exist in propositional logic. 

A richer logic such as ``Predicate Logic'' or ``First Order Logic'' (\emph{FOL}) is more suitable and has the expressive power to represent policies written in English. Moreover, FOL can be used to capture the meaning of policies in an unambiguous way.

Halpern and Weissman~\cite{Halpern2008} propose a fragment of FOL to represent and reason about policies. The fragment of FOL they arrive at is called \emph{Lithium} which is decidable and allows for efficiently answering interesting queries. Lithium restricts policies to be written based on the concept of ``bipolarity'' which disallows by construction policies that both permit and deny an action on an object. Pucella and Weissman~\cite{pucella2006} specify a predicate logic based language that represents a subset of ODRL.


\section{Specific Problem}

Policy languages and the agreements written in those languages are meant to implement specific goals such as limiting access to specific assets. The tension in designing a policy language is usually between how to make the language expressive enough, such that the design goals for the policy language may be expressed, and how to make the policies verifiable with respect to the stated goals.

As stated earlier, an important part of fulfilling the verifiability goal is to have formal semantics defined for policy languages. For \ac{odrl}, authors of~\cite{pucella2006} have defined a formal semantics based on which they declare and prove a number of important theorems (their main focus is on stating and proving algorithm complexity results). However as with many paper-proofs, the language used to do the proofs while mathematical in nature, uses a lot of intuitive justifications to show the proofs. As such these proofs are difficult to verify or more importantly to ``derive''. Furthermore the proofs can not be used directly to render a decision on a sample policy (e.g. whether to allow or deny access to an asset). Of course one may (carefully) construct a program based on these proofs for practical purposes but we will have no way of certifying those programs correct, even assuming the original proofs were in fact correct.

While there are paper-proofs for various properties of \ac{odrl} (e.g. the ones in~\cite{pucella2006}), proofs for similar properties do not exist for an important (mandatory) access-control policy system, namely \ac{selinux}. In particular, as far as we know, no formal proofs (paper based or otherwise) of decidablity of answering access control queries given an \ac{selinux} policy exists in the literature. 


\section{Contributions}

In this thesis we will build a language representation framework based on \ac{odrl} and definitions in~\cite{pucella2006}. The framework will be in \emph{Coq}~\cite{coqref} which is both a programming language and a proof-assistant. We will declare and prove decidablity results of subsets of \ac{odrl} all the way up to the complete \ac{odrl} fragment defined in~\cite{pucella2006}. We will extract programs from the proofs and demonstrate how they can be used on specific policies to render a specific decision such as ``a conflict has been detected''. 

Beside ``certified decidablity results'' for \ac{odrl}, we will investigate decidablity for \ac{selinux} policies, proving decidablity or show why a proof is not possible (if that is the case) and provide proposals to make the policy language decidable.

Decidablity results will subsume an important sub-category, namely inconsistency or conflict-detection in policy expressions or rules. Authors of~\cite{st2012verified} describe and implement in Coq a conflict detection algorithm for detecting conflicts in \ac{xacml} access control rules. \ac{xacml} is an expressive and at the same time complex policy language which makes conflict detection a difficult task. Authors of~\cite{st2012verified} then prove the conflict detection algorithm correct (or certified) by developing a formal proof in Coq. The proof is rather complex and involves a large number of cases, including many
corner cases that were difficult to get right~\cite{st2012verified}. 

By using the Coq framework originally built for \ac{odrl} to encode and verify agreements written in a second policy language (and different class of policy language: \ac{rel} vs access-control) we will demonstrate the suitability of this Coq based framework for other policy languages such as \ac{xacml}. 

This Coq based language framework could also be used to implement and reason about interoperability~\cite{prados2005interoperability}~\cite{maronas2009architecture} between various policy languages. In this manner our Coq based language (including possible modifications and enhancements due to supporting \ac{selinux}) can be viewed as \emph{abstract syntax}, complete with defined semantics, that can be used for implementing various policy languages with more concrete syntax (e.g. W3C's \ac{odrl} and \ac{selinux}). 

\section{What specific work has been accomplished until this point in time? what results were obtained so far?}

The encodings for a subset of \ac{odrl} which we call ODRL0 (see ~\ref{sec:odrl0}) plus some important functions implementing some of the algorithms in~\cite{pucella2006} have been implemented in Coq. Some of the intermediate theorems have been also been defined and proved.

\section{What remains to be done to complete the thesis research?}
The main decidablity result and its proof for ODRL0 will be completed first. We will add the remaining \ac{odrl} constructs incrementally while maintaining decidablity for the main decision algorithm. The remaining constructs include a trouble-some construct (~\cite{pucella2006}), namely $not[policySet]$. We will show this construct does not change the decidablity result already established. 

ODRL0 is enough to be used as a basis for \ac{selinux} policies without \emph{constrain}s. \ac{selinux} constrains are extra  conditions that need to be satisfied (in addition to policies) in order for a permission to be granted. We will investigate decidablity for this subset first. We will then add constrains to the ODRL0 subset (as pre-requisites) and investigate decidablity.



\section{What is the timetable to complete the work?}

The study plan calls for August of 2015 for everything to be completed.











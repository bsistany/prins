%======================================================================
\chapter{Introduction}
%======================================================================
Digital rights management, \emph{DRM}, refers to the digital management of rights associated with the access or usage of digital assets. There are various aspects of rights management however. According to the authors of the whitepaper ``A digital rights management ecosystem model for the education community,'' digital rights management systems cover the following four areas: 1) defining rights 2) distributing/acquiring rights 3) enforcing rights and 4) tracking usage \cite{collier}. 

Rights Expression Languages, \emph{RELs}, or more precisely when dealing with digital assets, Digital Rights Expression Languages \emph{DRELs} deal with the ``rights definition'' aspect of the DRM ecosystem. A DREL, allows the expression and definition of digital asset usage rights such that other areas of the DRM ecosystem namely the enforcement mechanism and the usage tracking components can function correctly.

Currently the most popular RELs are the eXtensible rights Markup Language, \emph{XrML} [bib], and the Open Digital Rights Language, \emph{ODRL} [bib]. Both of these languages are XML based and are considered declarative languages. XrML has been selected to be the REL for \emph{MPEG-21} which is an ISO standard for multimedia applications. ODRL is also a standards based REL which has been accepted as part of the W3C community with the mandate of standardizing how rights and policies, related to the usage of digital content on the Open Web Platform, \emph{OWP}, are expressed [wikipedia]. ODRL 2.0 supports expression of rights and also privacy rules for social media while ODRL 1.0 was only dealing with the mobile ecosystem -- ODRL 1.0 was adopted by the Open Mobile Alliance, \emph{OMA} in 2000.

As popular as both XrML and ODRL are, their adoption and usage is still somewhat limited in practice. Both Apple and Microsoft for example have defined their own lightweight RELs [problem with RELs paper] in \emph{Fair Play} (Apple) and in \emph{PlayReady} (Microsoft). The authors of [the problem with RELs] argue that both these RELs and other ones are simply too complex to be used effectively since they try to cover much of the DRM ecosystem. 

Another issue with the current batch of RELs are due to their semantics being expressed in a natural language (e.g. English). By necessity natural languages are ambiguous and open to interpretation. 

To formalize the semantics of RELS several approaches have been attempted by various authors. The main categories are logic based, operational semantics based interpreters and finally web ontology based (from the Knowledge Representation Field). In this thesis we will focus on the logic based approach to formalizing semantics and will study a specific logic based language that is a translation from a subset of ODRL.









%----------------------------------------------------------------------
\section{Logic Based Semantics for ODRL}
%----------------------------------------------------------------------

%See equation \ref{eqn_pi} on page \pageref{eqn_pi}.\footnote{A famous %equation.}

Formal logic can represent the statements and facts we express in a natural language like English. Propositional logic is expressive enough to express simple facts as propositions and allows uses connectives to allow for the negation, conjunction and disjunction of the facts. However propositional logic is not expressive enough to express policies of the kind used in languages like ODRL and XrML. For example, a simple policy expressed in English like ``All who pay 5 dollars can watch the movie Toy Story'' cannot be expressed in propositional logic because the concept of  variables doesn't exist. 

The higher order logic called ``Predicate Logic'' or ``First Order Logic'' \emph{FOL} is more suitable and has the expressive power to represent policies written in English. Moreover, FOL can be used to capture the meaning of policies in an unambiguous way.

Halpern and Weissman [Using First Order Logic to Reason about Policies] propose a fragment of FOL to represent and reason about policies. The fragment of FOL they arrive at is called \emph{Lithium} which is decidable and allows for efficiently answering interesting queries. Lithium restricts policies to be written based on the concept of ``bipolarity'' which disallows by construction policies that both permit and deny an action on an object.

\section{Pucella 2006}
Pucella and Weissman \cite{pucella2006} specify a predicate logic based based language that represents a subset of ODRL.

\section{what will I do?}


\subsection{Coq}


	• Program correctness
	• Formal verification of software
	• Certified programs
	• Proof assistant
	• Interactive and mechanized theorem proving
	• Examples of machine assisted proofs: CompCert, four-color theorem proof
	• Coq is based on a higher-order functional programming language
	• Dependent Types
		○ Subset types
		○ Easier than writing explicit proofs
	• Write formal specification and proofs that programs comply to their specification (a-short-intro-to-coq)
	• Automatically extract code from specifications as Ocaml or Haskell (a-short-intro)
	• Properties, programs and proofs are all formalized in the same language called CIC (Calculus of inductive Constructions). (a-short-intro)
	• Coq uses a sort called Prop for propositions
	• Coq art:
	• Well-formed propositions are assertions  one can express about values such as mathematical objects or even programs e.g. 3 < 8
		○ Note that assertions may be true, false or simply conjectures
		○ An assertion is only true in general if a proof is provided
		○ However hand written proofs are difficult to verify
		○ Coq provides an environment for developing proofs including a formal language to express proofs in, the language itself being built using proof theory making it possible to step by step verification of the proofs
		○ Mechanized proof verification requires a "proof" that the verification algorithm is correct itself in applying all the formal rules correctly







\section{Abstract Syntax}

\cite{pucella2006} uses abstract syntax instead of XML to express statements in the ODRL language. The abstract syntax used is a more compact representation than XML based language ODRL policies are written in and furthermore it simplifies specifying the semantics as we shall see. As an example here is an agreement written in ODRL and the comparable agreement expressed in the abstract syntax \cite{pucella2006}.

\lstset{language=XML}
\begin{lstlisting}[caption={agreement for Mary Smith in XML},label={lst:agreementxml}]
<agreement>
 <asset> <context> <uid> Treasure Island </uid> </context> </asset>
 <permission>
   <display>
    <constraint>
     <cpu> <context> <uid> Mary's computer </uid> </context> </cpu>
    </constraint>
   </display>
   <print>
    <constraint> <count> 2 </count> </constraint>
   </print>
  <requirement>
   <prepay>
    <payment> <amount currency="AUD"> 5.00</amount> </payment>
   </prepay>
  </requirement>
 </permission>
 <party> <context> <name> Mary Smith </name> </context> </party>
</agreement>
\end{lstlisting}

The agreement ~\ref{lst:agreementxml} is shown below using the syntax from \cite{pucella2006}.

\lstset{language=Pucella2006}
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}[frame=single, caption={agreement for Mary Smith as BNF (as used in ~\cite{pucella2006})},label={lst:agreementpucella2006}]
agreement
 for Mary Smith 
 about Treasure Island 
 with prePay[5.00] -> and[cpu[Mary's Computer] => display,
                                      count[2] => print].
\end{lstlisting}
\end{minipage} 

% \emph{prin\textsubscript{u}}
In the following we will cover the \emph{abstract syntax} of a subset of ODRL expressed as Coq's constructs such as \emph{Inductive Types} and Definitions. We will call this subset \emph{ODRL0} both because it is a variation of Pucella's ODRL language and also because it is missing some ODRL constructs such as \emph{Requirements} and \emph{Conditions} - we will add the missing pieces making up what we will call \emph{ODRL1} and perhaps \emph{ODRL2} (the latter only if needed). We will also describe ODRL0 in a \emph{BNF} grammar that looks more like Pucella's ODRL grammar. BNF style grammars are less formal as they give some suggestions about the surface syntax of expressions [Pierce1] without getting into lexical analysis and parsing related aspects such as precedence order of operators. The Coq version in contrast is more formal and could be directly used for building compilers and interpreters. We will present both the BNF version and the Coq version for each construct of ODRL0 [Pierce1]. To get started let's see what the listing ~\ref{lst:agreementpucella2006} would look like in ODRL0's Coq version.

\lstset{language=Coq}
\begin{lstlisting}[frame=single, caption={Coq version of agreement for Mary Smith},label={lst:marysmithagreementcoq}]

Agreement (Single MarySmith) Treasure Island 
 (PrimitivePolicySet (Constraint (PrePay 5.00))
  (AndPolicy 
   (NewList (PrimitivePolicy (Constraint 
                              (Principal 
                               (Single MarysComputer))) id1 Display)
   (Single (PrimitivePolicy (Constraint (Count 2)) id2 Print))))).
\end{lstlisting}


%\coqdoceol
%\coqdocvar{Agreement} (\coqdocvar{Single} \coqdocvar{Mary Smith}) \coqdocvar{Treasure Island} (\coqdocvar{PrimitivePolicySet} (\coqdocvar{Constraint} (\coqdocvar{PrePay} 5.00))\coqdoceol
%\coqdocindent{0.50em}
%(\coqdocvar{AndPolicy} (\coqdocvar{NewList} (\coqdocvar{PrimitivePolicy} (\coqdocvar{Constraint} (\coqdocvar{Principal} (\coqdocvar{Single} \coqdocvar{Mary's Computer}))) \coqdocvar{id1} \coqdocvar{Display})\coqdoceol
%\coqdocindent{6.00em}
%(\coqdocvar{Single} (\coqdocvar{PrimitivePolicy} (\coqdocvar{Constraint} (\coqdocvar{Count} 2)) \coqdocvar{id2} \coqdocvar{Print}))))).\coqdoceol
%\coqdocemptyline
%\coqdocemptyline

The top level ODRL0 production is the \emph{agreement}. An agreement expresses what actions a set of subjects may perform on an object and under what conditions. Syntactically an agreement is composed of a set of subjects/users called a \emph{principal} (\emph{prin}), an \emph{asset} and a \emph{Policy Set} (\emph{PolicySet}).

% agreement
\lstset{language=AST}
\begin{lstlisting}[frame=single, caption={agreement},label={lst:agreementast}]
<agreement> ::= 'agreement' 'for' <prin> 'about' <asset> 'with' <policySet> 
\end{lstlisting}

Principals or prins are composed of \emph{subjects} which are specified based on the application e.g. Alice, Bob, etc for the DRM application we will be using throughout.

% prin
\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={prin},label={lst:prinast}]
<prin> ::=  { <subject$_{1}$>, ..., <subject$_{m}$> }
\end{lstlisting}

% subject
\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={subject},label={lst:subjectast}]
<subject> ::= N
\end{lstlisting}

Assets are also application specific but similar to subjects we will use specific ones for the DRM application (taken from \cite{pucella2006}). \emph{ebook}, \emph{The Report} and \emph{latestJingle} are examples of specific subjects we will be using throughout. Syntactically an asset is just a positive number (\emph{N}).

% asset
\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={asset},label={lst:assetast}]
<asset> ::= N
\end{lstlisting}

Agreements include policy sets. Each policy set specifies a \emph{prerequisite} and a \emph{policy}. In general if the prerequisite holds the policy is taken into consideration. Otherwise the policy will not be looked at. Some policy sets are specified as \emph{exclusive}. The \emph{Primitive Exclusive Policy Sets} are exclusive to agreement's users in that only those users may perform the actions specified in the policy set. The implication is that all other users who are not specified in the agreement's principal (prin) are forbidden from performing the specified actions. Finally policy sets could be grouped together in a \emph{conjunction} allowing a single agreement to be associated with many policy sets. 


% policySet

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={policySet},label={lst:policySetast}]
<policySet> ::=  
	$\vert$ <PrimitivePolicySet> : <preRequisite> $\rightarrow$ <policy> 
	$\vert$ <PrimitiveExclusivePolicySet> : <preRequisite> $\mapsto$ <policy>	 
	$\vert$ <AndPolicySet> : 'and'[ <policySet$_{1}$>, ..., <policySet$_{m}$> ]
\end{lstlisting}

A policy specifies an action to be performed on an asset, depending of whether the policy's prerequisite holds or not. If the prerequisite holds the agreement's user is permitted to perform the action on the agreement's asset; otherwise permission is denied. Similar to policy sets, policies could also be grouped together in a conjunction. The policy also includes a unique identifier. The policy identifier is added to help the translation (from agreements to formulas) but is optional in ODRL proper.

% policy

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={policy},label={lst:policyast}]
<policy> ::=  
	$\vert$ <PrimitivePolicy> : <preRequisite> $\Rightarrow_{<policyId>}$ <act>
	$\vert$ <AndPolicy> : 'and'[ <policy$_{1}$>, ..., <policy$_{m}$> ]
\end{lstlisting}

An \emph{Action} (\emph{act}) is simply a positive number. Similar to assets and subjects, actions are application specific. Some example actions taken from \cite{pucella2006} are \emph{Display} and \emph{Print}.

% act
\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={act},label={lst:actast}]
<act> ::= N
\end{lstlisting}

A \emph{Policy Id} (\emph{policyId}) is a unique identifier specified as (increasing) positive integers. 

% id
\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={policyId},label={lst:policyIdast}]
<policyId> ::= N
\end{lstlisting}

In ODRL0 a \emph{prerequisite} is either true or it is a \emph{constraint}. The \emph{true} prerequisite always holds. A constraint is an intrinsic part of a policy and cannot be influenced by agreement's user. Minimum height requirements for popular attractions and rides are examples of we would consider a constraint. The constraint \emph{ForEachMember} is interesting in its expressive power but has complicated semantics as we shall see in the ~\ref{sec:Semantics} section. Roughly speaking, ForEachMember takes a prin (a list of subjects) and a list L of constraints. The ForEachConstraint holds if each subject in prin satisfies each constraint in L.\emph{NotCons} is a negation of a constraint. The set of prerequisites are closed under conjunction (\emph{AndPrqs}), disjunction (\emph{OrPrqs}) and exclusive disjunction (\emph{XorPrqs}).

% prq

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={preRequisite},label={lst:preRequisiteast}]
<preRequisite> ::=  
	$\vert$ <TruePrq> : 'True'
	$\vert$ <Constraint> : <constraint>	 
	$\vert$ <ForEachMember> : 'ForEachMember' [<prin> ; <constraint$_{1}$>, ..., <constraint$_{m}$> ]	
	$\vert$ <NotCons> : 'not' [ <constraint> ]
	$\vert$ <AndPrqs> : 'and'[ <preRequisite$_{1}$>, ..., <preRequisite$_{m}$> ]
	$\vert$ <OrPrqs> : 'or'[ <preRequisite$_{1}$>, ..., <preRequisite$_{m}$> ]
	$\vert$ <XorPrqs> : 'xor'[ <preRequisite$_{1}$>, ..., <preRequisite$_{m}$> ]		
\end{lstlisting}

Constraints are either \emph{Principal}, \emph{Count} or \emph{CountByPrin}. Principal constraints basically require matching to specified prins. For example, the user being Alice is a Principal constraint. A count constraint refers to a set of policies \emph{P} and specifies the number of times the user of an agreement has invoked the policies in P to justify her actions. If the count constraint is part of a policy then the set P is composed of the single policy. In the case that the count constraint is part of a policy set, the set P is the set of policies specified in the policy set.

% constraint
\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={constraint},label={lst:constraintast}]
<constraint> ::=  
	$\vert$ <Principal> : <prin>
	$\vert$ <Count> : 'Count' [N]
	$\vert$ <CountByPrin> : <prin> ('Count' [N])
\end{lstlisting}

% ---------------------------------- COQ -----------------------
\section{Coq Version}

\lstset{language=Coq}
\begin{lstlisting}[frame=single, caption={Coq version of agreement},label={lst:agreementcoq}]
Inductive agreement : Set :=
  | Agreement : prin -> asset -> policySet -> agreement.
\end{lstlisting}

% prin 
\lstset{language=Coq}
\begin{lstlisting}[frame=single, caption={prin},label={lst:princoq}]
Definition prin := nonemptylist subject.
\end{lstlisting}

% asset
\lstset{language=Coq}
\begin{lstlisting}[frame=single, caption={asset},label={lst:assetcoq}]
Definition asset := nat.
\end{lstlisting}



% subject
\lstset{language=Coq}
\begin{lstlisting}[frame=single, caption={subject},label={lst:subjectcoq}]
Definition subject := nat.
\end{lstlisting}


% policySet
\lstset{language=Coq}
\begin{lstlisting}[frame=single, caption={policySet},label={lst:policySetcoq}]
Inductive policySet : Set :=
  | PrimitivePolicySet : preRequisite -> policy -> policySet 
  | PrimitiveExclusivePolicySet : preRequisite -> policy  -> policySet 
  | AndPolicySet : nonemptylist policySet -> policySet.
\end{lstlisting}

% policy
\lstset{language=Coq}
\begin{lstlisting}[frame=single, caption={policy},label={lst:policycoq}]
Inductive policy : Set :=
  | PrimitivePolicy : preRequisite -> policyId -> act -> policy 
  | AndPolicy : nonemptylist policy -> policy.
\end{lstlisting}

% act
\lstset{language=Coq}
\begin{lstlisting}[frame=single, caption={act},label={lst:actcoq}]
Definition act := nat.
\end{lstlisting}

% id
\lstset{language=Coq}
\begin{lstlisting}[frame=single, caption={policyId},label={lst:policyIdcoq}]
Definition policyId := nat.
\end{lstlisting}

% prq
\lstset{language=Coq}
\begin{lstlisting}[frame=single, caption={preRequisite},label={lst:preRequisitecoq}]
Inductive preRequisite : Set :=
  | TruePrq : preRequisite
  | Constraint : constraint -> preRequisite 
  | ForEachMember : prin  -> nonemptylist constraint -> preRequisite
  | NotCons : constraint -> preRequisite 
  | AndPrqs : nonemptylist preRequisite -> preRequisite
  | OrPrqs : nonemptylist preRequisite -> preRequisite
  | XorPrqs : nonemptylist preRequisite -> preRequisite.
\end{lstlisting}

% constraint
\lstset{language=Coq}
\begin{lstlisting}[frame=single, caption={constraint},label={lst:constraintcoq}]
Inductive constraint : Set :=
  | Principal : prin  -> constraint 
  | Count : nat -> constraint 
  | CountByPrin : prin -> nat -> constraint.
\end{lstlisting}


%----------------------------------------------------------------------
\section{Semantics}
\label{sec:Semantics}

In this section, we describe the semantics of ODRL0 language by a translation from each language object (e.g. agreement) to a proposition in \emph{Coq}. The semantics will help answer queries of the form ``may subject \emph{s} perform action \emph{act} to asset \emph{a}?''. If the answer is yes, we say permission is granted. Otherwise permission is denied. 

Whether a permission is granted or denied depends on the agreements in question but also on the facts recorded in the environment. For ODRL0 those facts revolve around the number of times a policy has been used to justify an action. We encode this information in an \emph{environment} which is a conjunction of equalities of the form \emph{count(s, policyId) = n}. 

The Coq version of the count equality is a new inductive type called \emph{count_equality}. An environment is defined to be a non-empty list of count_equality objects.

\lstset{language=Coq, frame=single, caption={Environments and Counts},label={lst:environmentcoq}}
\begin{lstlisting}
Inductive count_equality : Set := 
   | CountEquality : subject -> policyId -> nat -> count_equality.

Inductive environment : Set := 
  | SingleEnv : count_equality -> environment
  | ConsEnv :  count_equality ->  environment -> environment.

\end{lstlisting}


The translation starts with the top level agreement element and proceeds by case analysis on the structure of the agreement. Note that each translation function takes an environment parameter.


\lstset{language=Coq, frame=single, caption={Translation of agreement},label={lst:transagreement}}
\begin{lstlisting}

Definition trans_agreement (e:environment)(ag:agreement) : Prop :=
  match ag with 
    | Agreement prin_u a ps => trans_ps e ps prin_u a
  end.

\end{lstlisting}

Translation of a policy set proceeds with case analysis of different Policy Set constructors. We then recurse into translation functions for the composing elements. The specific Coq propositions for each constructor is taken from the formula translation for each constructor defined in \cite{pucella2006}.

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Policy Set Translation {$\colon$} PrimitivePolicySet},label={lst:transpolicyformulaPrimitivePolicySet}]
$[\![ preRequisite \rightarrow policy]\!]^{prin_{u}, a}$ $\triangleq$ $\forall x$ $(\!( [\![prin_{u}]\!]_{x}$ $\land$ $[\![preRequisite]\!]^{getId (p), prin_{u}, a}_{x}) \rightarrow [\![policy]\!]^{positive, prin_{u}, a}_{x}             \!)$
\end{lstlisting}

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Policy Set Translation {$\colon$} PrimitiveExclusivePolicySet},label={lst:transpolicyformulaPrimitiveExclusivePolicySet}]
$[\![ preRequisite \mapsto policy]\!]^{prin_{u}, a}$ $\triangleq$ $\forall x$ $(\!( [\![prin_{u}]\!]_{x}$ $\land$ $[\![preRequisite]\!]^{getId (p), prin_{u}, a}_{x}) \rightarrow [\![policy]\!]^{positive, prin_{u}, a}_{x}             \!)$ $\land$ $\forall x$ $(\neg[\![prin_{u}]\!]_{x} \rightarrow [\![policy]\!]^{negative, a}_{x})$

\end{lstlisting}

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Policy Set Translation {$\colon$} AndPolicySet},label={lst:transpolicyformulaAndPolicySet}]
$[\![ and [policySet_{1}, ..., policySet_{m}]]\!]^{prin_{u}, a}$ $\triangleq$ $[\![policySet_{1}]\!]^{prin_{u}, a}$ $\land$ $...$ $\land$ $[\![policySet_{m}]\!]^{prin_{u}, a}$

\end{lstlisting}



\lstset{language=Coq, frame=single, caption={Translation of Policy Set},label={lst:transps}}
\begin{lstlisting}

Fixpoint trans_ps
  (e:environment)(ps:policySet)(prin_u:prin)(a:asset){struct ps} : Prop :=

let trans_ps_list := (fix trans_ps_list (ps_list:nonemptylist policySet)(prin_u:prin)(a:asset){struct ps_list}:=
  match ps_list with
    | Single ps1 => trans_ps e ps1 prin_u a
    | NewList ps ps_list' => ((trans_ps e ps prin_u a) /\ (trans_ps_list ps_list' prin_u a))
  end) in
    match ps with
    | PrimitivePolicySet prq p => forall x, (((trans_prin x prin_u) /\ 
                                   (trans_preRequisite e x prq (getId p) prin_u)) -> 
                                   (trans_policy_positive e x p prin_u a))  

    | PrimitiveExclusivePolicySet prq p => forall x, ((((trans_prin x prin_u) /\ 
                                              (trans_preRequisite e x prq (getId p) prin_u)) -> 
                                             (trans_policy_positive e x p prin_u a)) /\
                                            ((not (trans_prin x prin_u)) -> (trans_policy_negative e x p a)))
                   
    | AndPolicySet ps_list => trans_ps_list ps_list prin_u a
    end.
\end{lstlisting}

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Prin Translation {$\colon$} Single subject},label={lst:transprinSingle}]
$[\![ subject ]\!]_{x}$ $\triangleq$ $x=subject$

\end{lstlisting}

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Prin Translation {$\colon$} List of subjects},label={lst:transprinListOfSubjects}]


$[\![ \{ subject_{1}, ..., subject_{m} \} ]\!]_{x}$ $\triangleq$ $[\![subject_{1}]\!]_{x}$ $\lor$ $...$ $\lor$ $[\![subject_{m}]\!]_{x}$

\end{lstlisting}

\lstset{language=Coq, frame=single, caption={Translation of a Prin},label={lst:transprin}}
\begin{lstlisting}

Fixpoint trans_prin
  (x:subject)(p: prin): Prop :=

  match p with
    | Single s => (x=s)
    | NewList s rest => ((x=s) \/ trans_prin x rest)
  end.
\end{lstlisting}

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Positive Policy Translation {$\colon$} Single policy},label={lst:transpolicypositiveSingle}]

$[\![ preRequisite \Rightarrow_{policyId} act ]\!]^{positive, prin_{u}, a}_{x}$ $\triangleq$ $([\![ preRequisite ]\!]^{policyId, prin_{u}}_{x}) \Rightarrow Permitted(x, [\![act]\!], a)$

\end{lstlisting}



\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Positive Policy Translation {$\colon$} List of policies},label={lst:transpolicypositiveListOfPolicies}]

$[\![ and [policy_{1}, ..., policy_{m}]]\!]^{positive, prin_{u}, a}$ $\triangleq$ $[\![policy_{1}]\!]^{positive, prin_{u}, a}$ $\land$ $...$ $\land$ $[\![policy_{m}]\!]^{positive, prin_{u}, a}$

\end{lstlisting}






\lstset{language=Coq, frame=single, caption={Translation of a positive policy},label={lst:transpolicypositiveCoq}}
\begin{lstlisting}

Fixpoint trans_policy_positive
  (e:environment)(x:subject)(p:policy)(prin_u:prin)(a:asset){struct p} : Prop :=

let trans_p_list := (fix trans_p_list (p_list:nonemptylist policy)(prin_u:prin)(a:asset){struct p_list}:=
                  match p_list with
                    | Single p1 => trans_policy_positive e x p1 prin_u a
                    | NewList p p_list' => 
                        ((trans_policy_positive e x p prin_u a) /\ 
                         (trans_p_list p_list' prin_u a))
                  end) in


  match p with
    | PrimitivePolicy prq policyId action => ((trans_preRequisite e x prq (Single policyId) prin_u) ->
                                              (Permitted x action a))
    | AndPolicy p_list => trans_p_list p_list prin_u a
  end.
\end{lstlisting}






\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Negative Policy Translation {$\colon$} Single policy},label={lst:transpolicynegativeSingle}]

$[\![ preRequisite \Rightarrow_{policyId} act ]\!]^{negative, prin_{u}, a}_{x}$ $\triangleq$ $([\![ preRequisite ]\!]^{policyId, prin_{u}}_{x}) \Rightarrow \lnot (Permitted(x, [\![act]\!], a))$

\end{lstlisting}
\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Negative Policy Translation {$\colon$} List of policies},label={lst:transpolicynegativeListOfPolicies}]

$[\![ and [policy_{1}, ..., policy_{m}]]\!]^{negative, a}$ $\triangleq$ $[\![policy_{1}]\!]^{negative, a}$ $\land$ $...$ $\land$ $[\![policy_{m}]\!]^{negative, a}$


\end{lstlisting}

\lstset{language=Coq, frame=single, caption={Translation of a negative policy},label={lst:transpolicynegative}}
\begin{lstlisting}

Fixpoint trans_policy_negative
  (e:environment)(x:subject)(p:policy)(a:asset){struct p} : Prop :=
let trans_p_list := (fix trans_p_list (p_list:nonemptylist policy)(a:asset){struct p_list}:=
                  match p_list with
                    | Single p1 => trans_policy_negative e x p1 a
                    | NewList p p_list' => ((trans_policy_negative e x p a) /\ 
                                            (trans_p_list p_list' a))
                  end) in


  match p with
    | PrimitivePolicy prq policyId action => not (Permitted x action a)
    | AndPolicy p_list => trans_p_list p_list a
  end.

\end{lstlisting}

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Prerequisite Translation {$\colon$} Always True Prerequisite},label={lst:transpreRequisiteTruePrq}]
	$[\![ prerequisite::true ]\!]$ $\triangleq$ True
\end{lstlisting}

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Prerequisite Translation {$\colon$} Constraint},label={lst:transpreRequisiteConstraint}]

$[\![ prerequisite::constraint ]\!]^{[id_{1}, ..., id_{m}], prin_{u}}_{x}$ $\triangleq$ $[\![ constraint ]\!]^{[id_{1}, ..., id_{m}], prin_{u}}_{x}$ 
\end{lstlisting}

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Prerequisite Translation {$\colon$} ForEachMember},label={lst:transpreRequisiteForEachMember}]

$[\![ prerequisite::forEachMember ]\!]^{[subject_{1}, ..., subject_{k}], [constraint_{1}, ..., constraint_{m}], [id_{1}, ..., id_{n}]}_{x}$ $\triangleq$ $[\![ forEachMember ]\!]^{[subject_{1}, ..., subject_{k}], [constraint_{1}, ..., constraint_{m}], [id_{1}, ..., id_{n}]}_{x}$ 	
\end{lstlisting}

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Prerequisite Translation {$\colon$} Not Constraint},label={lst:transpreRequisiteNotConstraint}]

$[\![ not$ $prerequisite::constraint ]\!]^{[id_{1}, ..., id_{m}], prin_{u}}_{x}$ $\triangleq$ $\lnot[\![ constraint ]\!]^{[id_{1}, ..., id_{m}], prin_{u}}_{x}$ 
\end{lstlisting}


\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Prerequisite Translation {$\colon$} Conjunction },label={lst:transpreRequisiteAndPrqs}]

$[\![and$ $[preRequisite_{1}, ..., preRequisite_{k}]]\!]^{[id_{1}, ..., id_{m}], prin_{u}}$ $\triangleq$ $[\![preRequisite_{1}]\!]^{[id_{1}, ..., id_{m}], prin_{u}}$ $\land$ $...$ $\land$ $[\![preRequisite_{k}]\!]^{[id_{1}, ..., id_{m}], prin_{u}}$

\end{lstlisting}
\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Prerequisite Translation {$\colon$} Inclusive Disjunction},label={lst:transpreRequisiteOrPrqs}]

$[\![or$ $[preRequisite_{1}, ..., preRequisite_{k}]]\!]^{[id_{1}, ..., id_{m}], prin_{u}}$ $\triangleq$ $[\![preRequisite_{1}]\!]^{[id_{1}, ..., id_{m}], prin_{u}}$ $\lor$ $...$ $\lor$ $[\![preRequisite_{k}]\!]^{[id_{1}, ..., id_{m}], prin_{u}}$

\end{lstlisting}
\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Prerequisite Translation {$\colon$} Exclusive Disjunction},label={lst:transpreRequisiteXorPrqs}]

$[\![Xor$ $[preRequisite_{1}, ..., preRequisite_{k}]]\!]^{[id_{1}, ..., id_{m}], prin_{u}}$ $\triangleq$ $[\![preRequisite_{1}]\!]^{[id_{1}, ..., id_{m}], prin_{u}}$ $\oplus $ $...$ $\oplus$ $[\![preRequisite_{k}]\!]^{[id_{1}, ..., id_{m}], prin_{u}}$

\end{lstlisting}


\lstset{language=Coq, frame=single, caption={Translation of a PreRequisite},label={lst:transpreRequisite}}
\begin{lstlisting}

Definition trans_preRequisite
  (e:environment)(x:subject)(prq:preRequisite)(IDs:nonemptylist policyId)(prin_u:prin) : Prop := 

  match prq with
    | TruePrq => True
    | Constraint const => trans_constraint e x const IDs prin_u 
    | ForEachMember prn const_list => trans_forEachMember e x prn const_list IDs 
    | NotCons const => trans_notCons e x const IDs prin_u 
    | AndPrqs prqs => True 
    | OrPrqs prqs => True 
    | XorPrqs prqs => True 
  end.
\end{lstlisting}








\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Constraint Translation {$\colon$} Principal},label={lst:transconstraintPrin}]

$[\![ constraint::prin ]\!]^{[subject_{1}, ..., subject_{m}]}_{x}$ $\triangleq$ $[\![ prin ]\!]^{[subject_{1}, ..., subject_{m}]}_{x}$ 
\end{lstlisting}

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Constraint Translation {$\colon$} Count},label={lst:transconstraintCount}]

$[\![ constraint::count [N] ]\!]^{[id_{1}, ..., id_{m}], prin_{u}}_{x}$ $\triangleq$ $[\![ count [N] ]\!]^{[id_{1}, ..., id_{m}], prin_{u}}_{x}$ 
\end{lstlisting}


\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Constraint Translation {$\colon$} Count by Principal},label={lst:transconstraintCountbyPrin}]

$[\![ constraint::prin(count [N]) ]\!]^{[subject_{1}, ..., subject_{m}], [id_{1}, ..., id_{n}]}_{x}$ $\triangleq$ $[\![ prin(count [N]) ]\!]^{[subject_{1}, ..., subject_{m}], [id_{1}, ..., id_{n}]}_{x}$ 
\end{lstlisting}


\lstset{language=Coq, frame=single, caption={Translation of a Constraint},label={lst:transconstraint}}
\begin{lstlisting}

Fixpoint trans_constraint 
  (e:environment)(x:subject)(const:constraint)(IDs:nonemptylist policyId)
  (prin_u:prin){struct const} : Prop := 
  match const with
    | Principal prn => trans_prin x prn
  
    | Count n => trans_count e n IDs prin_u 

    | CountByPrin prn n => trans_count e n IDs prn 

  end.
  
\end{lstlisting}







\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={ForEachMember Translation {$\colon$} Count by Principal},label={lst:transforEachMember}]

$[\![ forEachMember ]\!]^{[subject_{1}, ..., subject_{k}], [constraint_{1}, ..., constraint_{m}], [id_{1}, ..., id_{n}]}_{x}$ $\triangleq$ $[\![constraint]\!]^{(subject_{1}, constraint_{1}), [id_{1}, ..., id_{n}]}_{x}$ $\land$ $...$ $\land$ $[\![constraint]\!]^{(subject_{1}, constraint_{m}), [id_{1}, ..., id_{n}]}_{x}$ $\land$ $...$ $\land$ $[\![constraint]\!]^{(subject_{2}, constraint_{1}), [id_{1}, ..., id_{n}]}_{x}$ $\land$ $...$ $\land$ $[\![constraint]\!]^{(subject_{2}, constraint_{m}), [id_{1}, ..., id_{n}]}_{x}$ $\land$ $...$ $\land$ $[\![constraint]\!]^{(subject_{k}, constraint_{1}), [id_{1}, ..., id_{n}]}_{x}$ $\land$ $...$ $\land$ $[\![constraint]\!]^{(subject_{k}, constraint_{m}), [id_{1}, ..., id_{n}]}_{x}$ 

\end{lstlisting}

\lstset{language=Coq, frame=single, caption={Translation of forEachMember},label={lst:transforEachMember}}
\begin{lstlisting}

Fixpoint trans_forEachMember
         (e:environment)(x:subject)(principals: nonemptylist subject)(const_list:nonemptylist constraint)
         (IDs:nonemptylist policyId){struct const_list} : Prop := 

let trans_forEachMember_Aux   
  := (fix trans_forEachMember_Aux
         (prins_and_constraints : nonemptylist (Twos subject constraint))
         (IDs:nonemptylist policyId){struct prins_and_constraints} : Prop :=

      match prins_and_constraints with
        | Single pair1 => trans_constraint e x (right pair1) IDs (Single (left pair1)) 
        | NewList pair1 rest_pairs =>
            (trans_constraint e x (right pair1) IDs (Single (left pair1))) /\
            (trans_forEachMember_Aux rest_pairs IDs)
      end) in

      let prins_and_constraints := process_two_lists principals const_list in
      trans_forEachMember_Aux prins_and_constraints IDs.

\end{lstlisting}


The translation for ``Not Constraint'' was listed in listing ~\ref{lst:transpreRequisiteNotConstraint} earlier but we repeat it here to go along the Coq version. 

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Not Constraint Translation},label={lst:transnotCons}]

$[\![ not$ $constraint ]\!]^{[id_{1}, ..., id_{m}], prin_{u}}_{x}$ $\triangleq$ $\lnot[\![ constraint ]\!]^{[id_{1}, ..., id_{m}], prin_{u}}_{x}$ 

\end{lstlisting}

\lstset{language=Coq, frame=single, caption={Translation of not cons},label={lst:transnotCons}}
\begin{lstlisting}

Definition trans_notCons
  (e:environment)(x:subject)(const:constraint)(IDs:nonemptylist policyId)(prin_u:prin) : Prop :=
  ~ (trans_constraint e x const IDs prin_u).
\end{lstlisting}



\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Count Translation {$\colon$} subject and policyId pair},label={lst:transcountSinglePair}]

$[\![ count [N] ]\!]^{subject_{1}, id_{1}}_{x}$ $\triangleq$ $getCount(subject_{1}, id_{1}) < N$
\end{lstlisting}

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Count Translation {$\colon$} subject and policyId pairs},label={lst:transcountPairs}]

$[\![ count [N] ]\!]^{[id_{1}, ..., id_{m}], prin_{u}}_{x}$ $\triangleq$ 

$(getCount(getSubject(prin_{u})_{1}, id_{1})$ $+ ... +$ $getCount(getSubject(prin_{u})_{1}, id_{m})$ $+ ... +$ $getCount(getSubject(prin_{u})_{k}, id_{1})$ $+ ... +$ $getCount(getSubject(prin_{u})_{k}, id_{m}))$ < $N$


\end{lstlisting}




\lstset{language=Coq, frame=single, caption={Translation of count},label={lst:transcount}}
\begin{lstlisting}
Fixpoint trans_count 
  (e:environment)(n:nat)(IDs:nonemptylist policyId)
  (prin_u:prin) : Prop := 

  let trans_count_aux 
    := (fix trans_count_aux
         (ids_and_subjects : nonemptylist (Twos policyId subject)) : nat :=
     match ids_and_subjects with
        | Single pair1 => getCount e (right pair1) (left pair1)
        | NewList pair1 rest_pairs =>
            (getCount e (right pair1)(left pair1)) +
            (trans_count_aux rest_pairs)
      end) in
  
  let ids_and_subjects := process_two_lists IDs prin_u in
  let running_total := trans_count_aux ids_and_subjects in
  running_total < n.
\end{lstlisting}
%======================================================================
\chapter{ODRL0 Syntax In Coq}
%======================================================================

% ---------------------------------- COQ -----------------------

ODRL0 productions were presented as high level abstract syntax in ~\ref{sec:productionast}. Below we present the corresponding encodings in Coq. 

An agreement is a new inductive type in Coq by the same name. The constructor $Agreement$ takes a $prin$, an $asset$ and a $policySet$. $prin$ is defined to be a non empty list of $subject$s (see ~\ref{lst:agreementcoq}). 

Types $asset$, $subject$, $act$ and $policyId$ are simply defined as $nat$ which is the datatype of natural numbers defined in coq's library module $Coq.Init.Datatypes$ ($nat$ is itself an inductive datatype). We use Coq constants to refer to specific objects of each type. For example, the subject 'Alice' is defined as $Definition Alice:subject := 101.$ and the act 'Play' as $Definition Play : act := 301.$. For each ``nat'' type in ODRL0 we have also used constants that play the role of ``Null'' objects (see ``Null Object Pattern'' ~\cite{martin1998pattern}), for example $NullSubject$. This is needed partly because of the way ODRL0 language elements are defined which corresponds to the need to use $nonemptylist$ exclusively even though at intermediate stages during the various algorithms Coq's $list$ is a better fit because it allows empty lists.

Next we define the $policySet$ datatype. Note the close/one-to-one mapping to its counterpart in ~\ref{lst:policySetast}. There are three ways a $policySet$ can be constructed (see ~\ref{lst:policySetast}) corresponding to three constructors: $PrimitivePolicySet$, $PrimitiveExclusivePolicySet$ and $AndPolicySet$. Both $PrimitivePolicySet$ and $PrimitiveExclusivePolicySet$ take a $preRequisite$ and a $policy$ as parameters. Finally $AndPolicySet$ takes a non empty list of $policySet$s.

A $policy$ is defined as a datatype with constructors $PrimitivePolicy$ and $AndPolicy$ (see ~\ref{lst:policyast}). $PrimitivePolicy$ takes a $preRequisite$, a $policyId$ and a action $act$. Ignoring the $policyId$ for a moment (it is only added to help the translation otherwise $policyId$s don't exist in ODRL proper), a primitive policy consists of a prerequisite and an action. If the prerequisite holds the action is allowed to be performed on the asset. The $AndPolicy$ constructor is simply a non empty list of $policy$s.


\lstset{language=Coq}
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}[frame=single, caption={Coq version of agreement},label={lst:agreementcoq}]
Inductive agreement : Set :=
  | Agreement : prin -> asset -> policySet -> agreement.

Definition prin := nonemptylist subject.

Definition asset := nat.

Definition subject := nat.

Definition act := nat.

Definition policyId := nat.

Inductive policySet : Set :=
  | PrimitivePolicySet : preRequisite -> policy -> policySet 
  | PrimitiveExclusivePolicySet : preRequisite -> policy  -> policySet 
  | AndPolicySet : nonemptylist policySet -> policySet.

Inductive policy : Set :=
  | PrimitivePolicy : preRequisite -> policyId -> act -> policy 
  | AndPolicy : nonemptylist policy -> policy.

\end{lstlisting}
\end{minipage}

A $preRequisite$ (see ~\ref{lst:preRequisiteast} for the abstract syntax equivalent) is defined as a new datatype with constructors $TruePrq$, $Constraint$, $ForEachMember$, $NotCons$, $AndPrqs$, $OrPrqs$ and $XorPrqs$. 

$TruePrq$ represents the always true prerequisite. The $Constraint$ prerequisite is defined as the type $constraint$ so its description is deferred here. Intuitively a constraint is a prerequisite to be satisfied that is outside the control of the user(s). For example, the constraint of being 'Alice' if you are 'Bob' (or 'Alice' for that matter). The constructor $ForEachMember$ is defined to be a $prin$ and a non empty list of $constraint$s. Intuitively a $ForEachMember$ prerequisite holds if each subject in $prin$ satisfies each constraint in the list of $constraint$s. The constructor $NotCons$ is defined the same way the $Constraint" constructor$ is. This constructor is defined as the type $constraint$ and it is meant to represent the negation of a $constraint$ as we shall see in the translation (see ~\ref{lst:transnotConsCoq}). The remaining constructors $AndPrqs$, $OrPrqs$ and $XorPrqs$ take as parameters non empty lists of prerequisites. They represent conjunction, inclusive disjunction and exclusive disjunction of prerequisites respectively. 

Finally a $constraint$ (see  ~\ref{lst:constraintast} for the abstract syntax equivalent) is defined as a new datatype with constructors $Principal$, $Count$ and $CountByPrin$. 

Principal constraint takes a $prin$ to match. For example, the constraint of the user being Bob would be represented as ``Principal constraint''. The $Count$ constructor takes a $nat$ which represents the number of times the user of an agreement has invoked the corresponding policies to justify her actions. If the count constraint is part of a policy then the corresponding policies is basically the single policy, whereas in the case that the count constraint is part of a policy set, the corresponding policies would be the set of those policies specified in the policy set. The $CountByPrin$ is similar to $Count$ but it takes an additional $prin$ parameter. In this case the subjects specified in the $prin$ parameter override the agreements' user(s).   

% prq
\lstset{language=Coq}
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}[frame=single, caption={preRequisite},label={lst:preRequisitecoq}]
Inductive preRequisite : Set :=
  | TruePrq : preRequisite
  | Constraint : constraint -> preRequisite 
  | ForEachMember : prin  -> nonemptylist constraint -> preRequisite
  | NotCons : constraint -> preRequisite 
  | AndPrqs : nonemptylist preRequisite -> preRequisite
  | OrPrqs : nonemptylist preRequisite -> preRequisite
  | XorPrqs : nonemptylist preRequisite -> preRequisite.
  
  
Inductive constraint : Set :=
  | Principal : prin  -> constraint 
  | Count : nat -> constraint 
  | CountByPrin : prin -> nat -> constraint.

\end{lstlisting}
\end{minipage}


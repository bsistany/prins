%======================================================================
\chapter{ODRL0 Syntax In Coq}
%======================================================================

% ---------------------------------- COQ -----------------------
\section{Introduction to Coq}

Coq is known first and foremost as a proof-assistant. The underlying formal language that Coq uses is a much more expressive version of typed lambda calculus called \ac{cic} where proofs and programs can both be represented. For example, \ac{cic} adds polymorphisn (terms depending on types), type operators (types depending on types) and dependent types (types depending on terms).

Specifications of programs in Coq may be expressed using the specification language \emph{Gallina}~\cite{gallinaref}. Coq is then used to develop proofs to show that a program's run-time behavior satisfies its specification. Such programs are called \emph{certified} because they are formally verified and confirmed to conform to their specifications~\cite{BC04}.

Assertions or propositions are statements about values in Coq such as $3<8$ or $8<3$ that may be true, false or even be only conjectures. To verify that a proposition is true a proof needs to constructed. While paper-proofs use a combination of mathematics and natural language to describe their proofs, Coq provides a formal (and therefore unambiguous) language that is based on proof-theory to develop proofs in. Verification of complex proofs is possible because one can verify the intermediate proofs or sub-goals in steps, each step being derived from the previous by following precise derivation rules. The Coq proof engine solves successive goals by using predefined \emph{tactics}. Coq tactics are commands to manipulate the local context and to decompose a goal into simpler goals or sub-goals~\cite{BC04}.

\section{ODRL0 Syntax}

ODRL0 productions were presented as high level abstract syntax in ~\ref{sec:productionast}. Below we present the corresponding encodings in Coq. 

An agreement is a new inductive type in Coq by the same name. The constructor $Agreement$ takes a $prin$, an $asset$ and a $policySet$. $prin$ is defined to be a non empty list of $subject$s (see listing~\ref{lst:agreementcoq}). 

Types $asset$, $subject$, $act$ and $policyId$ are simply defined as $nat$ which is the datatype of natural numbers defined in coq's library module $Coq.Init.Datatypes$ ($nat$ is itself an inductive datatype). We use Coq constants to refer to specific objects of each type. For example, the subject 'Alice' is defined as $Definition Alice:subject := 101.$ and the act 'Play' as $Definition Play : act := 301.$. For each ``nat'' type in ODRL0 we have also used constants that play the role of ``Null'' objects (see ``Null Object Pattern''~\cite{martin1998pattern}), for example $NullSubject$. This is needed partly because of the way ODRL0 language elements are defined which corresponds to the need to use $nonemptylist$ exclusively even though at intermediate stages during the various algorithms Coq's $list$ is a better fit because it allows empty lists.

Next we define the $policySet$ datatype. Note the close/one-to-one mapping to its counterpart in listing~\ref{lst:policySetast}. There are three ways a $policySet$ can be constructed (see listing~\ref{lst:policySetast}) corresponding to three constructors: $PrimitivePolicySet$, $PrimitiveExclusivePolicySet$ and $AndPolicySet$. Both $PrimitivePolicySet$ and $PrimitiveExclusivePolicySet$ take a $preRequisite$ and a $policy$ as parameters. Finally $AndPolicySet$ takes a non empty list of $policySet$s.

A $policy$ is defined as a datatype with constructors $PrimitivePolicy$ and $AndPolicy$ (see listing~\ref{lst:policyast}). $PrimitivePolicy$ takes a $preRequisite$, a $policyId$ and a action $act$. Ignoring the $policyId$ for a moment (it is only added to help the translation otherwise $policyId$s don't exist in ODRL proper), a primitive policy consists of a prerequisite and an action. If the prerequisite holds the action is allowed to be performed on the asset. The $AndPolicy$ constructor is simply a $nonemptylist$ (see listing~\ref{lst:nonemptylistcoq}) of $policy$s. 

The data type $nonemptylist$ reflects the definition of ``policy conjunction'' in listing listing~\ref{lst:policyast} in chapter ~\ref{chap:odrl0syntax} (see definition of $nonemptylist$ in listing~\ref{lst:nonemptylistcoq}). Essentially $nonemptylist$ represents a list data structure that has at least one element and it is defined as a new \emph{polymorphic} inductive type in its own section. 

\lstset{language=Coq}
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}[frame=single, caption={Coq Version of Agreement},label={lst:agreementcoq}]
Inductive agreement : Set :=
  | Agreement : prin -> asset -> policySet -> agreement.

Definition prin := nonemptylist subject.

Definition asset := nat.

Definition subject := nat.

Definition act := nat.

Definition policyId := nat.

Inductive policySet : Set :=
  | PrimitivePolicySet : preRequisite -> policy -> policySet 
  | PrimitiveExclusivePolicySet : preRequisite -> policy  -> policySet 
  | AndPolicySet : nonemptylist policySet -> policySet.

Inductive policy : Set :=
  | PrimitivePolicy : preRequisite -> policyId -> act -> policy 
  | AndPolicy : nonemptylist policy -> policy.

\end{lstlisting}
\end{minipage}



\lstset{language=Coq, frame=single, caption={nonemptylist},label={lst:nonemptylistcoq}}
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}

Section nonemptylist.

Variable X : Set.

Inductive nonemptylist : Set :=
  | Single : X -> nonemptylist 
  | NewList : X -> nonemptylist -> nonemptylist.

End nonemptylist.
\end{lstlisting}
\end{minipage}


In listing~\ref{lst:preRequisitecoq} $preRequisite$ is defined as a new datatype with constructors $TruePrq$, $Constraint$, $ForEachMember$, $NotCons$, $AndPrqs$, $OrPrqs$ and $XorPrqs$ (see listing~\ref{lst:preRequisiteast} for the abstract syntax equivalent).

$TruePrq$ represents the always true prerequisite. The $Constraint$ prerequisite is defined as the type $constraint$ so its description is deferred here. Intuitively a constraint is a prerequisite to be satisfied that is outside the control of the user(s). For example, the constraint of being 'Alice' if you are 'Bob' (or 'Alice' for that matter). The constructor $ForEachMember$ is defined to be a $prin$ and a non empty list of $constraint$s. Intuitively a $ForEachMember$ prerequisite holds if each subject in $prin$ satisfies each constraint in the list of $constraint$s. The constructor $NotCons$ is defined the same way the $Constraint" constructor$ is. This constructor is defined as the type $constraint$ and it is meant to represent the negation of a $constraint$ as we shall see in the translation (see listing~\ref{lst:transnotConsCoq}). The remaining constructors $AndPrqs$, $OrPrqs$ and $XorPrqs$ take as parameters non empty lists of prerequisites. They represent conjunction, inclusive disjunction and exclusive disjunction of prerequisites respectively. 

Finally a $constraint$ (see  listing~\ref{lst:constraintast} for the abstract syntax equivalent) is defined as a new datatype with constructors $Principal$, $Count$ and $CountByPrin$. 

Principal constraint takes a $prin$ to match. For example, the constraint of the user being Bob would be represented as ``Principal constraint''. The $Count$ constructor takes a $nat$ which represents the number of times the user of an agreement has invoked the corresponding policies to justify her actions. If the count constraint is part of a policy then the corresponding policies is basically the single policy, whereas in the case that the count constraint is part of a policy set, the corresponding policies would be the set of those policies specified in the policy set. The $CountByPrin$ is similar to $Count$ but it takes an additional $prin$ parameter. In this case the subjects specified in the $prin$ parameter override the agreements' user(s).   

% prq
\lstset{language=Coq}
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}[frame=single, caption={preRequisite},label={lst:preRequisitecoq}]
Inductive preRequisite : Set :=
  | TruePrq : preRequisite
  | Constraint : constraint -> preRequisite 
  | ForEachMember : prin  -> nonemptylist constraint -> preRequisite
  | NotCons : constraint -> preRequisite 
  | AndPrqs : nonemptylist preRequisite -> preRequisite
  | OrPrqs : nonemptylist preRequisite -> preRequisite
  | XorPrqs : nonemptylist preRequisite -> preRequisite.
  
  
Inductive constraint : Set :=
  | Principal : prin  -> constraint 
  | Count : nat -> constraint 
  | CountByPrin : prin -> nat -> constraint.

\end{lstlisting}
\end{minipage}

